<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Monad | Good Times Paradigms</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="Monad">
<meta property="og:locale" content="en_US">
<meta name="description" content="Learning Outcomes">
<meta property="og:description" content="Learning Outcomes">
<meta property="og:site_name" content="Good Times Paradigms">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-09-30T03:56:06+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Monad">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-30T03:56:06+00:00","datePublished":"2025-09-30T03:56:06+00:00","description":"Learning Outcomes","headline":"<span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span>","mainEntityOfPage":{"@type":"WebPage","@id":"/<span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span>/"},"url":"/<span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span>/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="/assets/images/favicon.ico">
    <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Good Times Paradigms"><!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-159840333-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-159840333-1');
</script><!-- MathJax v3 -->
<script>
  window.MathJax = {
    tex: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true }
  };
</script>
<script defer="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
  <script src="/assets/js/spoilers.js" defer=""></script></head>

  <body><header class="site-header">

    <div class="wrapper"><!-- Lambda icon and site title aligned left in a flex container -->
        <div style="display: flex; align-items: center;">
            <button id="play-theme-song" style="background:none;border:none;cursor:pointer;vertical-align:middle;margin-right:2px;" title="Play theme song">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="24" fill="currentColor" viewBox="0 0 48 24" style="vertical-align:middle;">
                    <text x="4" y="20" font-size="20" font-family="serif">ΓΤΠ</text>
                    <!-- γτπ -->
                </svg>
            </button>
            <a class="site-title" rel="author" href="/" style="margin:0;">Good Times Paradigms</a>
        </div>
        <script src="/assets/js/hide_solutions.js" defer=""></script>
        <audio id="theme-song" src="/assets/themesong.mp3"></audio>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                var btn = document.getElementById('play-theme-song');
                var audio = document.getElementById('theme-song');
                btn.addEventListener('click', function() {
                    if (audio.paused) {
                        audio.play();
                    } else {
                        audio.pause();
                        audio.currentTime = 0;
                    }
                });
            });
        </script><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger">
            <label for="nav-trigger">
                <span class="menu-icon">
                </span>
            </label>

            <div class="nav-items"><a class="page-link nav-item" href="/about/">About</a><a class="page-link nav-item" href="/">Notes on Programming Paradigms</a><!-- Radio Switch -->
                <div id="toggle-div" style="display: none;">
                    <div class="solutions-toggle">
                        <p class="page-link" style="margin-bottom: 0px;">Show Solutions?</p>
                        <label class="switch" style="vertical-align: middle;">
                            <input type="checkbox" id="toggle-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
        </nav></div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
	
  

  


<div id="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
        
        
        <a id="left" href="/haskell4/">&lt; <span class="glossary-term" data-term="foldable">Foldable<span class="glossary-popup">A type class for data structures that can be folded (reduced) to a single value. It includes functions like foldr, foldl, length, null, elem, maximum, minimum, sum, product, and foldMap.
</span></span> and <span class="glossary-term" data-term="traversable">Traversable<span class="glossary-popup">A type class for data structures that can be traversed, applying a function with an Applicative effect to each element. It extends both Foldable and Functor and includes functions like traverse and sequenceA.
</span></span></a>
      
      
        
        
        <a id="right" href="/eithers/">Eithers &gt;</a>
      
    
  
    
  
    
  
    
  
</div>

	<header class="post-header">
		<h1 class="post-title">Monad</h1>
	</header>
	<p id="readingTime">

  
  28

 min read</p>
	<div class="post-content">
		<h2 id="learning-outcomes">Learning Outcomes</h2>

<ul>
  <li>Understand that <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> extends <a href="/haskell3"><span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> and <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span></a> to provide a <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> <code class="language-plaintext highlighter-rouge">(&gt;&gt;=)</code> operation which allows us to sequence effectful operations such that their effects are flattened or joined into a single effect.</li>
  <li>Understand the operation of the monadic <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> and join functions in the <code class="language-plaintext highlighter-rouge">Maybe</code>, <code class="language-plaintext highlighter-rouge">IO</code>, List and Function instances of <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span>.</li>
  <li>Be able to refactor monadic <span class="glossary-term" data-term="binds">binds<span class="glossary-popup">The defining function which all monads must implement.
</span></span> using <a href="#do-notation"><code class="language-plaintext highlighter-rouge">do</code> notation</a>.</li>
  <li><a href="#looping-with-monadic-effects">Loop with <span class="glossary-term" data-term="monadic effects">Monadic effects<span class="glossary-popup">Operations that produce side effects and are managed within a monadic context, ensuring that the effects are sequenced and controlled.
</span></span></a>.</li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>As with <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> and <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>, the name <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> comes from Category Theory.  Although the names sound mathematical, they are abstractions of relatively simple concepts.  A <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> allowed unary functions to be applied (mapped/<code class="language-plaintext highlighter-rouge">fmap</code>ed) over a context.  <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> allowed us to apply a function in a context to values in a context.  So too, <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> has a characteristic function called “<span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span>”, which allows us to perform another type of function application over values in a context.</p>

<p>The special thing about <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> is that it allows us to chain functions that have an effect without creating additional layers of nesting inside effect contexts.  People often try to describe <span class="glossary-term" data-term="monads">Monads<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> in metaphors, which are not always helpful.  The essence of <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> really is <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> and there is no getting around looking at its type signature and seeing what it does in different instances, which we will get to shortly.  However, one analogy that resonated for me was the idea of <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> as a <a href="http://book.realworldhaskell.org/read/monads.html">“programmable semicolon”</a>.  That is, imagine a language like JavaScript which uses semicolons (<code class="language-plaintext highlighter-rouge">;</code>) as a statement separator:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// some javascript you can try in a browser console:</span>
<span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nf">prompt</span><span class="p">(</span><span class="dl">"</span><span class="s2">Name?</span><span class="dl">"</span><span class="p">);</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello </span><span class="dl">"</span><span class="o">+</span><span class="nx">x</span><span class="p">)</span>
</code></pre></div></div>

<p>As we will see shortly, the Haskell <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> operator <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code> can also be used to sequence expressions with an IO effect:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">getLine</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">putStrLn</span><span class="p">(</span><span class="s">"hello "</span><span class="o">++</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>However, it not only separates the two expressions, but also safely handles the <code class="language-plaintext highlighter-rouge">IO</code> type within which all code with IO <span class="glossary-term" data-term="side effects">side effects<span class="glossary-popup">Any state change that occurs outside of a function’s local environment or any observable interaction with the outside world, such as modifying a global variable, writing to a file, or printing to a console.
</span></span> in Haskell must operate.  But as well as allowing us to chain effectful operations, <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> is defined to do different and useful things for different <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> instances, as we shall see.</p>

<h2 id="the-monad-typeclass">The Monad Typeclass</h2>

<p>As always, we can interrogate GHCi to get a basic synopsis of the <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> typeclass:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">Monad</span>
<span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
  <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
  <span class="n">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="o">...</span>
  <span class="cp">{-# MINIMAL (&gt;&gt;=) #-}</span>
        <span class="c1">-- Defined in `GHC.Base'</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- Defined in `Data.Either'</span>
<span class="kr">instance</span> <span class="p">[</span><span class="n">safe</span><span class="p">]</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span>
  <span class="c1">-- Defined in `transformers-0.5.2.0:Control.Monad.Trans.Reader'</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="c1">-- Defined in `GHC.Base'</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="c1">-- Defined in `GHC.Base'</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">IO</span> <span class="c1">-- Defined in `GHC.Base'</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in `GHC.Base'</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in `GHC.Base'</span>
</code></pre></div></div>

<p>Things to notice:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Monad</code> is a subclass of <code class="language-plaintext highlighter-rouge">Applicative</code> (and therefore also a <code class="language-plaintext highlighter-rouge">Functor</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">return</code> = <code class="language-plaintext highlighter-rouge">pure</code>, from <a href="/haskell3/#applicative"><code class="language-plaintext highlighter-rouge">Applicative</code></a>. The <code class="language-plaintext highlighter-rouge">return</code> function exists for historical reasons and you can safely use only <code class="language-plaintext highlighter-rouge">pure</code> (PureScript has only <code class="language-plaintext highlighter-rouge">pure</code>).</li>
  <li>the operator <code class="language-plaintext highlighter-rouge">(&gt;&gt;=)</code> (pronounced “<span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span>”) is the minimal definition (the one function you must create—in addition to the functions also required for <code class="language-plaintext highlighter-rouge">Functor</code> and <code class="language-plaintext highlighter-rouge">Applicative</code>—to make a new <code class="language-plaintext highlighter-rouge">Monad</code> instance).</li>
  <li><code class="language-plaintext highlighter-rouge">&gt;&gt;</code> is a special case of <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> (described below)</li>
  <li>lots of built-in types are already <span class="glossary-term" data-term="monads">monads<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span></li>
</ul>

<p>There also exists a flipped version of <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">=&lt;&lt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">flip</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
</code></pre></div></div>

<p>The type of the flipped <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> <code class="language-plaintext highlighter-rouge">(=&lt;&lt;)</code> has a nice correspondence to the other operators we have already seen for function application in various contexts:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">=&lt;&lt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span>       <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span>     <span class="o">=&gt;</span>   <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">$</span><span class="p">)</span>   <span class="o">::</span>                    <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span>   <span class="o">-&gt;</span> <span class="n">b</span>
</code></pre></div></div>

<p>So the <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> function <code class="language-plaintext highlighter-rouge">(&gt;&gt;=)</code> (and equally its flipped version <code class="language-plaintext highlighter-rouge">(=&lt;&lt;)</code>) gives us another way to map functions over contexts—but why do we need another way?</p>

<p>As an example we’ll consider computation using the <code class="language-plaintext highlighter-rouge">Maybe</code> type, which we said is useful for <a href="/haskell2/#maybe"><span class="glossary-term" data-term="partial functions">partial functions<span class="glossary-popup">Functions that do not have a mapping for every input, potentially failing for some inputs.
</span></span></a>, that is, functions which are not sensibly defined over all of their inputs.  A more complex example of such a function than we have seen before is the <a href="https://en.wikipedia.org/wiki/Quadratic_formula">quadratic formula</a> which, for quadratic functions of the form:</p>

\[ax^2 + bx + c = 0\]

<p>determines two roots:</p>

\[x_1 = \frac{-b + \sqrt{b^2 - 4ac}}{2a}
\quad \text{and} \quad
x_2 = \frac{-b - \sqrt{b^2 - 4ac}}{2a}\]

<p>This may fail in two ways:</p>

<ol>
  <li>if <em>a</em> is 0 (divide by 0 is undefined);</li>
  <li>if the expression that square root is applied to is negative (and we insist on only real-valued solutions).</li>
</ol>

<p>Therefore, let’s define a little library of math functions that encapsulate the possibility of failure in a <code class="language-plaintext highlighter-rouge">Maybe</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">safeDiv</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Float</span>
<span class="n">safeDiv</span> <span class="kr">_</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">safeDiv</span> <span class="n">numerator</span> <span class="n">denominator</span> <span class="o">=</span> <span class="kt">Just</span> <span class="o">$</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>

<span class="n">safeSqrt</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Float</span>
<span class="n">safeSqrt</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">Nothing</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="kt">Just</span> <span class="o">$</span> <span class="n">sqrt</span> <span class="n">x</span> <span class="c1">-- the built-in square root function</span>
</code></pre></div></div>

<p>Great!  Now we can use <code class="language-plaintext highlighter-rouge">case</code> and <span class="glossary-term" data-term="pattern matching">pattern matching<span class="glossary-popup">A mechanism in functional programming languages to check a value against a pattern and to deconstruct data.
</span></span> to make a safe solver of quadratic equations:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">safeSolve</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Float</span><span class="p">,</span> <span class="kt">Float</span><span class="p">)</span>
<span class="n">safeSolve</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">safeSqrt</span> <span class="o">$</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="n">s</span> <span class="o">-&gt;</span>
            <span class="kr">let</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">safeDiv</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">safeDiv</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
            <span class="kr">in</span> <span class="kr">case</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span> <span class="kr">of</span>
                <span class="p">(</span><span class="kt">Just</span> <span class="n">x1'</span><span class="p">,</span> <span class="kt">Just</span> <span class="n">x2'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">x1'</span><span class="p">,</span><span class="n">x2'</span><span class="p">)</span>
                <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
        <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>

<span class="o">&gt;</span> <span class="n">safeSolve</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span>
<span class="kt">Just</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="n">safeSolve</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="kt">Nothing</span>
</code></pre></div></div>

<p>Actually, not so great, we are having to unpack <span class="glossary-term" data-term="maybes">Maybes<span class="glossary-popup">A built-in type in Haskell used to represent optional values, allowing functions to return either Just a value or Nothing to handle cases where no value is available.
</span></span> multiple times, leading to nested <code class="language-plaintext highlighter-rouge">case</code>s.  This is just two levels of nesting; what happens if we need to work in additional computations that can fail?</p>

<p>The general problem is that we need to chain multiple functions of the form <code class="language-plaintext highlighter-rouge">Float -&gt; Maybe Float</code>.  Let’s look again at the type of <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</code></pre></div></div>

<p>The first argument it expects is a value in a context <code class="language-plaintext highlighter-rouge">m a</code>.  What if that we apply it to a <code class="language-plaintext highlighter-rouge">Maybe Float</code>?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">::</span><span class="kt">Float</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
<span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</code></pre></div></div>

<p>So GHCi is telling us that the next argument has to be a function that takes a <code class="language-plaintext highlighter-rouge">Float</code> as input, and gives back anything in a <code class="language-plaintext highlighter-rouge">Maybe</code>.  Our <code class="language-plaintext highlighter-rouge">safeSqrt</code> definitely fits this description, as does <code class="language-plaintext highlighter-rouge">safeDiv</code> partially applied to a <code class="language-plaintext highlighter-rouge">Float</code>.  So, here’s a <code class="language-plaintext highlighter-rouge">safeSolve</code> which uses <code class="language-plaintext highlighter-rouge">(&gt;&gt;=)</code> to remove the need for <code class="language-plaintext highlighter-rouge">case</code>s:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">safeSolve</span> <span class="o">::</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Float</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Float</span><span class="p">,</span> <span class="kt">Float</span><span class="p">)</span>
<span class="n">safeSolve</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span>
    <span class="n">safeSqrt</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span>
    <span class="n">safeDiv</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x1</span> <span class="o">-&gt;</span>
    <span class="n">safeDiv</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x2</span> <span class="o">-&gt;</span>
    <span class="n">pure</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">safeSolve</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span>
<span class="kt">Just</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span><span class="o">-</span><span class="mf">2.0</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="n">safeSolve</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="kt">Nothing</span>
</code></pre></div></div>

<p>Note that Haskell has a special notation for such multi-line use of <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span>, called “<code class="language-plaintext highlighter-rouge">do</code> notation”.  The above code in a <code class="language-plaintext highlighter-rouge">do</code> block looks like:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">safeSolve</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">s</span> <span class="o">&lt;-</span> <span class="n">safeSqrt</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">x1</span> <span class="o">&lt;-</span> <span class="n">safeDiv</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">&lt;-</span> <span class="n">safeDiv</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
    <span class="n">pure</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>
</code></pre></div></div>

<p>So inside a <code class="language-plaintext highlighter-rouge">do</code>-block <code class="language-plaintext highlighter-rouge">y&lt;-x</code> is completely equivalent to <code class="language-plaintext highlighter-rouge">x &gt;&gt;= \y -&gt; …</code>, where in both cases the variable <code class="language-plaintext highlighter-rouge">y</code> is in scope for the rest of the expression.  We’ll see more <a href="/monad/#do-notation">explanation and examples of <code class="language-plaintext highlighter-rouge">do</code> notation below</a>.</p>

<p>How is a <code class="language-plaintext highlighter-rouge">Nothing</code> result from either of our <code class="language-plaintext highlighter-rouge">safe</code> functions handled?  Well, the <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#line-1005"><span class="glossary-term" data-term="maybe">Maybe<span class="glossary-popup">A built-in type in Haskell used to represent optional values, allowing functions to return either Just a value or Nothing to handle cases where no value is available.
</span></span> instance of <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span></a> defines <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> like so:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span>  <span class="kt">Monad</span> <span class="kt">Maybe</span>  <span class="kr">where</span>
    <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>      <span class="o">=</span> <span class="n">k</span> <span class="n">x</span>
    <span class="kt">Nothing</span>  <span class="o">&gt;&gt;=</span> <span class="kr">_</span>      <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>Meaning that anything on the right-hand side of a <code class="language-plaintext highlighter-rouge">Nothing&gt;&gt;=</code> will be left unevaluated and <code class="language-plaintext highlighter-rouge">Nothing</code> returned.</p>

<p>So that’s one instance of <code class="language-plaintext highlighter-rouge">Monad</code>; let’s look at some more…</p>

<h3 id="io">IO</h3>

<p>The Haskell type that captures Input/Output effects is called <code class="language-plaintext highlighter-rouge">IO</code>.  As we demonstrated with the <code class="language-plaintext highlighter-rouge">traverse</code> function, it is possible to perform <code class="language-plaintext highlighter-rouge">IO</code> actions using <code class="language-plaintext highlighter-rouge">fmap</code> (<code class="language-plaintext highlighter-rouge">&lt;$&gt;</code>) and <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> (<code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>)—for example printing to the console. The challenge is taking values out of an <code class="language-plaintext highlighter-rouge">IO</code> context and using them to create further <code class="language-plaintext highlighter-rouge">IO</code> effects.</p>

<p>Here are some simple <code class="language-plaintext highlighter-rouge">IO</code> “actions”:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sayHi</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">sayHi</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="s">"Hi, what’s your name?"</span>
<span class="n">readName</span> <span class="o">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="n">readName</span> <span class="o">=</span> <span class="n">getLine</span>
<span class="n">greet</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">greet</span> <span class="n">name</span> <span class="o">=</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Nice to meet you "</span> <span class="o">++</span> <span class="n">name</span> <span class="o">++</span> <span class="s">"!"</span><span class="p">)</span>
</code></pre></div></div>

<p>The following typechecks:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="n">greet</span> <span class="o">&lt;$&gt;</span> <span class="n">readName</span>
</code></pre></div></div>

<p>When you run it from either GHCi or an executable compiled with GHC, it will pause and wait for input, but you will not see the subsequent greeting.
This is because the type of the expression is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">greet</span> <span class="o">&lt;$&gt;</span> <span class="n">readName</span>
<span class="n">greet</span> <span class="o">&lt;$&gt;</span> <span class="n">readName</span> <span class="o">::</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">IO</span> <span class="nb">()</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">IO</code> action we want (<code class="language-plaintext highlighter-rouge">greet</code>) is nested inside another <code class="language-plaintext highlighter-rouge">IO</code> action.  When it is run, only the outer <code class="language-plaintext highlighter-rouge">IO</code> action is actually executed. The inner <code class="language-plaintext highlighter-rouge">IO</code> computation (action) is not evaluated.
To see an output we somehow need to flatten the <code class="language-plaintext highlighter-rouge">IO (IO ())</code> into just a single level: <code class="language-plaintext highlighter-rouge">IO ()</code>.
<code class="language-plaintext highlighter-rouge">(&gt;&gt;=)</code> gives us this ability:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">readName</span> <span class="o">&gt;&gt;=</span> <span class="n">greet</span>
<span class="n">readName</span> <span class="o">&gt;&gt;=</span> <span class="n">greet</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>

<span class="o">&gt;</span> <span class="n">readName</span> <span class="o">&gt;&gt;=</span> <span class="n">greet</span>
</code></pre></div></div>

<blockquote>
  <p>Tim<br>
Nice to meet you Tim!</p>
</blockquote>

<p>The special case of <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> <code class="language-plaintext highlighter-rouge">(&gt;&gt;)</code> allows us to chain actions without passing through a value:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>

<span class="o">&gt;</span> <span class="n">sayHi</span> <span class="o">&gt;&gt;</span> <span class="n">readName</span> <span class="o">&gt;&gt;=</span> <span class="n">greet</span>
</code></pre></div></div>

<blockquote>
  <p>Hi, what’s your name?<br>
Tim<br>
Nice to meet you Tim!</p>
</blockquote>

<h3 id="do-notation">Do notation</h3>

<p>Haskell gives us syntactic sugar for <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> in the form of “do blocks”:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">sayHi</span>
   <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">readName</span>
   <span class="n">greet</span> <span class="n">name</span>
</code></pre></div></div>

<p>Which is entirely equivalent to the above code, or more explicitly:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span>
   <span class="n">sayHi</span> <span class="o">&gt;&gt;</span>
   <span class="n">readName</span> <span class="o">&gt;&gt;=</span>
   <span class="nf">\</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">greet</span> <span class="n">name</span>
</code></pre></div></div>

<p>Note that although <code class="language-plaintext highlighter-rouge">&lt;-</code> looks like assignment to a variable <code class="language-plaintext highlighter-rouge">name</code>, it actually expands to a parameter name for a lambda expression following the <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span>.  Thus, the way I read the line with the <code class="language-plaintext highlighter-rouge">&lt;-</code> in the following do expression:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">do</span>
  <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">readName</span>
  <span class="n">greet</span> <span class="n">name</span>
</code></pre></div></div>

<p>is:</p>

<p><em>Take the value</em> (a <code class="language-plaintext highlighter-rouge">String</code> in this case)
<em>out of the <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> context resulting from the expression on the right-hand side of the <code class="language-plaintext highlighter-rouge">&lt;-</code></em> (i.e. <code class="language-plaintext highlighter-rouge">readName</code>) <em>and assign it to the symbol on the left-hand side</em> (i.e. <code class="language-plaintext highlighter-rouge">name</code>) <em>which remains in scope until the end of the <code class="language-plaintext highlighter-rouge">do</code> block:</em></p>

<p>You can also mix in variable assignments from pure expressions using let:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">do</span>
  <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">readName</span>
  <span class="kr">let</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">"Hello "</span> <span class="o">++</span> <span class="n">name</span>
  <span class="n">putStrLn</span> <span class="n">greeting</span>
</code></pre></div></div>

<h3 id="join">Join</h3>

<p>A function called <code class="language-plaintext highlighter-rouge">join</code> from <code class="language-plaintext highlighter-rouge">Control.Monad</code> also distils the essence of <code class="language-plaintext highlighter-rouge">Monad</code> nicely.  Its type and definition in terms of <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> are:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">join</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">join</span> <span class="o">=</span> <span class="p">(</span><span class="o">&gt;&gt;=</span> <span class="n">id</span><span class="p">)</span>
</code></pre></div></div>

<p>We can use <code class="language-plaintext highlighter-rouge">join</code> to flatten nested <code class="language-plaintext highlighter-rouge">Maybe</code>s:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">join</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">Nothing</span><span class="p">)</span>
<span class="kt">Nothing</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">join</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">7</span><span class="p">))</span>
<span class="kt">Just</span> <span class="mi">7</span>
</code></pre></div></div>

<p>We can apply join to “flatten” the nested <code class="language-plaintext highlighter-rouge">IO</code> contexts from the earlier <code class="language-plaintext highlighter-rouge">fmap</code> example:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">join</span> <span class="o">$</span> <span class="n">greet</span> <span class="o">&lt;$&gt;</span> <span class="n">readName</span>
<span class="n">join</span> <span class="o">$</span> <span class="n">greet</span> <span class="o">&lt;$&gt;</span> <span class="n">readName</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</code></pre></div></div>

<p>Which will now execute as expected:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">join</span> <span class="o">$</span> <span class="n">greet</span> <span class="o">&lt;$&gt;</span> <span class="n">readName</span>
</code></pre></div></div>

<blockquote>
  <p>Tim<br>
Nice to meet you Tim!</p>
</blockquote>

<h2 id="list">List</h2>

<p>As with the <a href="/haskell3/#applicative"><span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> list instance</a>, the list implementation of <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#Monad">is defined</a> with comprehension <span class="glossary-term" data-term="syntax">syntax<span class="glossary-popup">The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.
</span></span>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span>  <span class="kr">where</span>
    <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">f</span> <span class="n">x</span><span class="p">]</span>
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">xs</code> is a list and <code class="language-plaintext highlighter-rouge">f</code> is a function that returns a list.  <code class="language-plaintext highlighter-rouge">f</code> is applied to each element of <code class="language-plaintext highlighter-rouge">xs</code> and the result is concatenated.  Actually, list comprehensions are just syntactic sugar for the list <span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> <code class="language-plaintext highlighter-rouge">do</code> notation, for example, <code class="language-plaintext highlighter-rouge">[(i,j)|i&lt;-['a'..'d'],j&lt;-[1..4]]</code> is equivalent to:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">do</span>
  <span class="n">i</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'d'</span><span class="p">]</span>
  <span class="n">j</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]</span>
  <span class="n">pure</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>[(‘a’,1),(‘a’,2),(‘a’,3),(‘a’,4),(‘b’,1),(‘b’,2),(‘b’,3),(‘b’,4),(‘c’,1),(‘c’,2),(‘c’,3),(‘c’,4),(‘d’,1),(‘d’,2),(‘d’,3),(‘d’,4)]</p>
</blockquote>

<p>which is itself syntactic sugar for:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'d'</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">j</span> <span class="o">-&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
</code></pre></div></div>

<p>List comprehensions can also include conditional expressions which must evaluate to true for terms to be included in the list result.  For example, we can limit the above comprehension to only pairs with even <code class="language-plaintext highlighter-rouge">j</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span><span class="o">&lt;-</span><span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'d'</span><span class="p">],</span> <span class="n">j</span><span class="o">&lt;-</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">],</span> <span class="n">j</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>This comprehension <span class="glossary-term" data-term="syntax">syntax<span class="glossary-popup">The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.
</span></span> desugars to a <code class="language-plaintext highlighter-rouge">do</code>-block using the <code class="language-plaintext highlighter-rouge">guard</code> function from <code class="language-plaintext highlighter-rouge">Control.Monad</code> like so:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">guard</span><span class="p">)</span>

<span class="kr">do</span>
  <span class="n">i</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'d'</span><span class="p">]</span>
  <span class="n">j</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">]</span>
  <span class="n">guard</span> <span class="o">$</span> <span class="n">j</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="n">pure</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>[(‘a’,2),(‘a’,4),(‘b’,2),(‘b’,4),(‘c’,2),(‘c’,4),(‘d’,2),(‘d’,4)]</p>
</blockquote>

<p>Our friend <code class="language-plaintext highlighter-rouge">join</code> in the list <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> is simply concatenation:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">join</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<p>You can think of the way that results in the List <span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> are chained as being a logical extension of the way <code class="language-plaintext highlighter-rouge">Maybe</code> <span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> operations are chained. That is, a <code class="language-plaintext highlighter-rouge">Maybe</code> returns either zero or one result, while a list returns an arbitrary number of results. The result of two list operations chained with <code class="language-plaintext highlighter-rouge">(&gt;&gt;=)</code> is the Cartesian product in a flat list.</p>

<h2 id="function">Function</h2>

<p>We saw <a href="https://tgdwyer.github.io/haskell3/#functor">previously that functions are instances of <code class="language-plaintext highlighter-rouge">Functor</code></a>, such that <code class="language-plaintext highlighter-rouge">fmap = (.)</code>.  We also saw that <a href="https://tgdwyer.github.io/haskell3/#applicative">functions are <code class="language-plaintext highlighter-rouge">Applicative</code></a> such that a binary function (such as <code class="language-plaintext highlighter-rouge">(+)</code>) can be lifted over multiple functions that need to be applied to the same argument, e.g.:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">totalMark</span> <span class="o">::</span> <span class="kt">Student</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">totalMark</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">exam</span> <span class="n">nonExam</span>
</code></pre></div></div>

<p>So it shouldn’t really be any surprise that functions of the same input type can also be composed with monadic <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span>.
The right-to-left <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> <code class="language-plaintext highlighter-rouge">(=&lt;&lt;)</code> takes a binary function <code class="language-plaintext highlighter-rouge">f</code> and a unary function <code class="language-plaintext highlighter-rouge">g</code> and
creates a new unary function.
The new function will apply <code class="language-plaintext highlighter-rouge">g</code> to its argument, then give the result as well as the
original argument to <code class="language-plaintext highlighter-rouge">f</code>.
OK, that might seem a bit esoteric, but it lets us achieve some nifty things.</p>

<p>For example, below we compute <code class="language-plaintext highlighter-rouge">(3*2) + 3</code>, but we did it by using the argument <code class="language-plaintext highlighter-rouge">3</code>
in two different functions without explicitly passing it to either!</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="o">=&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="mi">3</span>
<span class="mi">9</span>
</code></pre></div></div>

<p>You can imagine a situation where you need to chain together a bunch of functions, but
they all take a common parameter, e.g. a line break character.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">greet</span> <span class="n">linebreak</span> <span class="o">=</span> <span class="s">"Dear Gentleperson,"</span><span class="o">++</span><span class="n">linebreak</span> 
<span class="n">body</span> <span class="n">sofar</span> <span class="n">linebreak</span> <span class="o">=</span> <span class="n">sofar</span> <span class="o">++</span> <span class="n">linebreak</span> <span class="o">++</span> <span class="s">"It has come to my attention that… "</span> <span class="o">++</span> <span class="n">linebreak</span>
<span class="n">signoff</span> <span class="n">sofar</span> <span class="n">linebreak</span> <span class="o">=</span> <span class="n">sofar</span> <span class="o">++</span> <span class="n">linebreak</span> <span class="o">++</span> <span class="s">"Yours truly,"</span> <span class="o">++</span> <span class="n">linebreak</span> <span class="o">++</span> <span class="s">"Tim"</span> <span class="o">++</span> <span class="n">linebreak</span>
<span class="n">putStrLn</span> <span class="o">$</span> <span class="p">(</span><span class="n">greet</span> <span class="o">&gt;&gt;=</span> <span class="n">body</span> <span class="o">&gt;&gt;=</span> <span class="n">signoff</span><span class="p">)</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span>
</code></pre></div></div>

<blockquote>
  <p>Dear Gentleperson,</p>

  <p>It has come to my attention that…</p>

  <p>Your’s truly,<br>
Tim</p>
</blockquote>

<p>In the next example we use the argument <code class="language-plaintext highlighter-rouge">3</code> in three different functions without passing it directly to any of them.
Note the pattern is that the right-most function is unary (taking only the specified argument), and subsequent functions in the chain are binary, their first argument being the result of the previous function application, and the second argument being the given <code class="language-plaintext highlighter-rouge">3</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="p">((</span><span class="o">*</span><span class="p">)</span> <span class="o">=&lt;&lt;</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="o">=&lt;&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">))</span> <span class="mi">3</span>
<span class="mi">9</span>
</code></pre></div></div>

<p>We can use the flipped <span class="glossary-term" data-term="bind">bind<span class="glossary-popup">The defining function which all monads must implement.
</span></span> so it can be read left-to-right, if that’s more your thing:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span> <span class="mi">3</span>
<span class="mi">9</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">join</code> function passes one argument to a binary function twice which can be a useful trick:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">join</span> <span class="p">(,))</span> <span class="mi">3</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">join</span> <span class="p">(</span><span class="o">+</span><span class="p">))</span> <span class="mi">3</span>
<span class="mi">6</span>
</code></pre></div></div>

<h3 id="returning-to-point-free">Returning To Point-Free</h3>

<p>The very observant reader may recognise the above construct of passing one argument to a binary function twice. We previously called this <code class="language-plaintext highlighter-rouge">apply</code>, when discussing <a href="/haskell3#applicative-exercises">Function instances for <span class="glossary-term" data-term="applicatives">applicatives<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span></a>. This can be a very useful pattern when making code point-free.</p>

<p>We previously gave you an exercise, and labeled it as a <em>scary extension</em>, but now with more tools, we can make this much less scary:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span>
</code></pre></div></div>

<p>First, let’s use join to apply the binary function (<code class="language-plaintext highlighter-rouge">*</code>) to the same argument twice</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">join</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">join</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>One function, you may have been introduced to in your travels is <code class="language-plaintext highlighter-rouge">on</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">on</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">on</code> function in Haskell takes a binary function, a unary function, and two arguments. It first applies the unary function to each argument separately, and then applies the binary function to the results of these applications. Using some <span class="glossary-term" data-term="operator sectioning">operator sectioning<span class="glossary-popup">The process of partially applying an infix operator in Haskell by specifying one of its arguments. For example, (+1) is a section of the addition operator with 1 as the second argument.
</span></span>, we can see our code fits exactly that pattern.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">((</span><span class="n">join</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span> <span class="n">a</span><span class="p">)</span> <span class="p">((</span><span class="n">join</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span> <span class="n">b</span><span class="p">)</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">on</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">join</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span> <span class="n">a</span> <span class="n">b</span>
</code></pre></div></div>

<p>We can now do two rounds of eta-conversion to make our code point-free.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="n">on</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">join</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span>
</code></pre></div></div>

<p>By convention, the <code class="language-plaintext highlighter-rouge">on</code> function is normally written as an infix operation, i.e., surrounded by backticks</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">join</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
</code></pre></div></div>

<p>This is quite a common pattern in Haskell code, where this code says we apply the <code class="language-plaintext highlighter-rouge">+</code> operation, after applying <code class="language-plaintext highlighter-rouge">join (*)</code> (multiplying by itself) to each argument.</p>

<h2 id="looping-with-monadic-effects">Looping with Monadic Effects</h2>

<p>There are also various functions in <code class="language-plaintext highlighter-rouge">Control.Monad</code> for looping functions with <span class="glossary-term" data-term="monadic effects">monadic effects<span class="glossary-popup">Operations that produce side effects and are managed within a monadic context, ensuring that the effects are sequenced and controlled.
</span></span> (functions that return a result inside a <span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span>) over containers that are <code class="language-plaintext highlighter-rouge">Foldable</code> and <code class="language-plaintext highlighter-rouge">Traversable</code>.</p>

<p>First, there’s <code class="language-plaintext highlighter-rouge">mapM</code>, is effectively the same as <code class="language-plaintext highlighter-rouge">traverse</code> (but requires the function to have a monadic effect, not just <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">doubleIfNotBig</span> <span class="n">n</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">n</span><span class="p">)</span> <span class="kr">else</span> <span class="kt">Nothing</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mapM</span> <span class="n">doubleIfNotBig</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mapM</span> <span class="n">doubleIfNotBig</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>Such monadic looping functions also have versions with a trailing <code class="language-plaintext highlighter-rouge">_</code> in their name, which throw away the actual results computed and just accumulate the effect (internally they use <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> instead of <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code>):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">mapM_</span> <span class="n">doubleIfNotBig</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mapM_</span> <span class="n">doubleIfNotBig</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kt">Just</span> <span class="nb">()</span>
</code></pre></div></div>

<p>For folks who have been missing <span class="glossary-term" data-term="imperative">imperative<span class="glossary-popup">Imperative programs are a sequence of statements that change a program’s state.  This is probably the dominant paradigm for programming languages today.  Languages from Assembly to Python are built around this concept and most modern languages still allow you to program in this style.
</span></span> for loops, there is a flipped version of <code class="language-plaintext highlighter-rouge">mapM_</code>, called <code class="language-plaintext highlighter-rouge">forM_</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">forM_</span> <span class="p">[</span><span class="s">"It"</span><span class="p">,</span><span class="s">"looks"</span><span class="p">,</span><span class="s">"like"</span><span class="p">,</span><span class="s">"JavaScript!"</span><span class="p">]</span> <span class="n">putStrLn</span>
<span class="kt">It</span>
<span class="n">looks</span>
<span class="n">like</span>
<span class="kt">JavaScript</span><span class="o">!</span>
</code></pre></div></div>

<p>And of course we can fold using functions with <span class="glossary-term" data-term="monadic effects">Monadic effects<span class="glossary-popup">Operations that produce side effects and are managed within a monadic context, ensuring that the effects are sequenced and controlled.
</span></span>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">small</span> <span class="n">acc</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="kt">Nothing</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">foldM</span> <span class="n">small</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">9</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">45</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">foldM</span> <span class="n">small</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
<span class="kt">Nothing</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p><span class="glossary-term" data-term="monads">Monads<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> really round out Haskell, making it a very powerful language with elegant ways to abstract common programming patterns. So far, we have looked at the <code class="language-plaintext highlighter-rouge">Maybe</code>, <code class="language-plaintext highlighter-rouge">IO</code>, and <code class="language-plaintext highlighter-rouge">List</code> <span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> instances. The <code class="language-plaintext highlighter-rouge">Maybe</code> <span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> allowed us to chain operations which may fail (in a more principled way than exception handling); <code class="language-plaintext highlighter-rouge">IO</code> allowed us to chain operations which perform input and output; and the <code class="language-plaintext highlighter-rouge">List</code> instance of <span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> allows us to sequence operations that may have multiple results (flattening the Cartesian product of the results).</p>

<p>We’ll see <span class="glossary-term" data-term="monads">Monads<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> at work again in the next chapter when we build more sophisticated <a href="/parsercombinators"><span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> <span class="glossary-term" data-term="combinators">combinators<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span></a>. Additionally, here’s a discussion about how to <a href="/randmonad">thread state such as random seeds</a> through functions using a custom monadic context, which serves as an introduction to the built-in <code class="language-plaintext highlighter-rouge">State</code> <span class="glossary-term" data-term="monad">monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span>.</p>

<p>With everything we’ve covered so far you should now be empowered to go out and write real-world programs. A slightly more advanced topic which you would soon encounter in the wild would be working within multiple monadic contexts at once. The most standard way to do this is using <a href="https://en.wikibooks.org/wiki/Haskell/Monad_transformers"><span class="glossary-term" data-term="monad">Monad<span class="glossary-popup">A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.
</span></span> Transformers</a>, but there are other approaches emerging, such as <a href="https://github.com/fused-effects/fused-effects">algebraic effects libraries</a>.  We’ll leave these for future self-exploration though.</p>

<div class="glossary">
  <h2 id="glossary">Glossary</h2>

  <p><em>Monad</em>: A type class in Haskell that represents computations as a series of steps. It provides the bind operation (»=) to chain operations and the return (or pure) function to inject values into the monadic context.</p>

  <p><em>Do Notation</em>: A syntactic sugar in Haskell for chaining monadic operations. It makes the code more readable by hiding the explicit use of bind (»=).</p>

  <p><em>Monadic Effects</em>: Operations that produce side effects and are managed within a monadic context, ensuring that the effects are sequenced and controlled.</p>

  <p><em>bind</em>: The defining function which all monads must implement.</p>

</div>

	</div>
	
  

  


<div id="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
        
        
        <a id="left" href="/haskell4/">&lt; <span class="glossary-term" data-term="foldable">Foldable<span class="glossary-popup">A type class for data structures that can be folded (reduced) to a single value. It includes functions like foldr, foldl, length, null, elem, maximum, minimum, sum, product, and foldMap.
</span></span> and <span class="glossary-term" data-term="traversable">Traversable<span class="glossary-popup">A type class for data structures that can be traversed, applying a function with an Applicative effect to each element. It extends both Foldable and Functor and includes functions like traverse and sequenceA.
</span></span></a>
      
      
        
        
        <a id="right" href="/eithers/">Eithers &gt;</a>
      
    
  
    
  
    
  
    
  
</div>

</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">
<footer class="site-footer h-card">
    <data class="u-url" href="/"></data>

    <div class="wrapper">

        <div class="footer-col-wrapper">
            <div class="footer-col">
                <!-- <p class="feed-subscribe">
                <a href="/feed.xml">
                    <svg class="svg-icon orange">
                        <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
                    </svg><span>Subscribe</span>
                </a>
                </p> -->
        </div>
        <div class="footer-col">
            <p>Examples and tutorials for various programming paradigms.</p>
        </div>
    </div>

    <!-- <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="" target="_blank" title="">
      <span class="grey fa-brands fa- fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="" target="_blank" title="">
      <span class="grey fa-brands fa- fa-lg"></span>
    </a>
  </li>
  <li>
    <a href="/feed.xml" target="_blank" title="Subscribe to syndication feed">
      <svg class="svg-icon grey" viewbox="0 0 16 16">
        <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
          11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
          13.806c0-1.21.983-2.195 2.194-2.195zM10.606
          16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
        />
      </svg>
    </a>
  </li>
</ul>
</div> -->

    </div>

</footer>



</body></html>