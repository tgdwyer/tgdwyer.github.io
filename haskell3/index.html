<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Functor and Applicative | Good Times Paradigms</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="Functor and Applicative">
<meta property="og:locale" content="en_US">
<meta name="description" content="In this chapter we see how the Haskell language features we introduced in previous chapters (from function application rules based on Lambda Calculus to Typeclasses) lead to highly flexible and refactorable code and powerful abstractions.">
<meta property="og:description" content="In this chapter we see how the Haskell language features we introduced in previous chapters (from function application rules based on Lambda Calculus to Typeclasses) lead to highly flexible and refactorable code and powerful abstractions.">
<meta property="og:site_name" content="Good Times Paradigms">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-09-30T03:56:06+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Functor and Applicative">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-30T03:56:06+00:00","datePublished":"2025-09-30T03:56:06+00:00","description":"In this chapter we see how the Haskell language features we introduced in previous chapters (from function application rules based on <span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> to Typeclasses) lead to highly flexible and refactorable code and powerful abstractions.","headline":"<span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> and <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>","mainEntityOfPage":{"@type":"WebPage","@id":"/haskell3/"},"url":"/haskell3/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="/assets/images/favicon.ico">
    <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Good Times Paradigms"><!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-159840333-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-159840333-1');
</script><!-- MathJax v3 -->
<script>
  window.MathJax = {
    tex: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true }
  };
</script>
<script defer="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
  <script src="/assets/js/spoilers.js" defer=""></script></head>

  <body><header class="site-header">

    <div class="wrapper"><!-- Lambda icon and site title aligned left in a flex container -->
        <div style="display: flex; align-items: center;">
            <button id="play-theme-song" style="background:none;border:none;cursor:pointer;vertical-align:middle;margin-right:2px;" title="Play theme song">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="24" fill="currentColor" viewBox="0 0 48 24" style="vertical-align:middle;">
                    <text x="4" y="20" font-size="20" font-family="serif">ΓΤΠ</text>
                    <!-- γτπ -->
                </svg>
            </button>
            <a class="site-title" rel="author" href="/" style="margin:0;">Good Times Paradigms</a>
        </div>
        <script src="/assets/js/hide_solutions.js" defer=""></script>
        <audio id="theme-song" src="/assets/themesong.mp3"></audio>
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                var btn = document.getElementById('play-theme-song');
                var audio = document.getElementById('theme-song');
                btn.addEventListener('click', function() {
                    if (audio.paused) {
                        audio.play();
                    } else {
                        audio.pause();
                        audio.currentTime = 0;
                    }
                });
            });
        </script><nav class="site-nav">
            <input type="checkbox" id="nav-trigger" class="nav-trigger">
            <label for="nav-trigger">
                <span class="menu-icon">
                </span>
            </label>

            <div class="nav-items"><a class="page-link nav-item" href="/about/">About</a><a class="page-link nav-item" href="/">Notes on Programming Paradigms</a><!-- Radio Switch -->
                <div id="toggle-div" style="display: none;">
                    <div class="solutions-toggle">
                        <p class="page-link" style="margin-bottom: 0px;">Show Solutions?</p>
                        <label class="switch" style="vertical-align: middle;">
                            <input type="checkbox" id="toggle-switch">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>
        </nav></div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">
	
  

  


<div id="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
        
        
        <a id="left" href="/haskell2/">&lt; Data Types and <span class="glossary-term" data-term="type classes">Type Classes<span class="glossary-popup">A type system construct in Haskell that defines a set of functions that can be applied to different types, allowing for polymorphic functions.
</span></span></a>
      
      
        
        
        <a id="right" href="/haskell4/">Foldable and Traversable &gt;</a>
      
    
  
    
  
    
  
    
  
    
  
    
  
</div>

	<header class="post-header">
		<h1 class="post-title">Functor and Applicative</h1>
	</header>
	<p id="readingTime">

  
  79

 min read</p>
	<div class="post-content">
		<p>In this chapter we see how the Haskell language features we introduced in previous chapters (from function application rules based on <a href="/lambdacalculus"><span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span></a> to <a href="/haskell2#typeclasses">Typeclasses</a>) lead to highly flexible and refactorable code and powerful abstractions.</p>

<h2 id="learning-outcomes">Learning Outcomes</h2>

<ul>
  <li>Understand how <a href="#eta-conversion">eta-conversion</a>, <a href="#operator-sectioning"><span class="glossary-term" data-term="operator sectioning">operator sectioning<span class="glossary-popup">The process of partially applying an infix operator in Haskell by specifying one of its arguments. For example, (+1) is a section of the addition operator with 1 as the second argument.
</span></span></a> and <a href="#compose">compose</a> together provide the ability to transform code to achieve a composable <a href="#point-free-code">point-free</a> form and use this technique to refactor code</li>
  <li>Understand that in Haskell the ability to map over container structures is generalised into the <a href="#functor"><span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span></a> typeclass, such that any type that is an instance of <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> has the <code class="language-plaintext highlighter-rouge">fmap</code> or <code class="language-plaintext highlighter-rouge">(&lt;$&gt;)</code> operation</li>
  <li>Understand that the <a href="#applicative"><span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> Typeclass</a> extends <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> such that containers of functions may be applied (using the <code class="language-plaintext highlighter-rouge">(&lt;*&gt;)</code> operator) to containers of values</li>
  <li>Understand that <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> and <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> allow powerful composable types through exploring a <a href="#a-simple-applicative-functor-for-parsing">simple <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> <span class="glossary-term" data-term="functor">functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> for parsing</a></li>
</ul>

<div class="cheatsheet">

  <h2 id="refactoring-cheatsheet">Refactoring Cheatsheet</h2>

  <p>The following equivalences make many refactorings possible in Haskell:</p>

  <h3 id="eta-conversion">Eta Conversion</h3>

  <p>Exactly as per <a href="/lambdacalculus"><span class="glossary-term" data-term="lambda calculus">Lambda Calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span></a>:</p>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="err">≡</span> <span class="n">g</span> <span class="n">x</span>
<span class="n">f</span>   <span class="err">≡</span> <span class="n">g</span>
</code></pre></div>  </div>

  <h3 id="operator-sectioning">Operator Sectioning</h3>

  <p>Remember Haskell binary operators are just infix <span class="glossary-term" data-term="curried functions">curried functions<span class="glossary-popup">Functions that take multiple arguments one at a time and return a series of functions.
</span></span> of two parameters and that putting brackets around them makes them prefix instead of infix.</p>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="err">≡</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">x</span> <span class="n">y</span>
      <span class="err">≡</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span> <span class="n">y</span>  <span class="c1">-- making function application precedence explicit</span>
      <span class="err">≡</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="p">)</span> <span class="n">y</span>     <span class="c1">-- binary operators can also be partially applied</span>
</code></pre></div>  </div>

  <p>Such <span class="glossary-term" data-term="operator sectioning">operator sectioning<span class="glossary-popup">The process of partially applying an infix operator in Haskell by specifying one of its arguments. For example, (+1) is a section of the addition operator with 1 as the second argument.
</span></span> allows us to get the right-most parameter of the function on its own at the right-hand side of the body expression such that we can apply <span class="glossary-term" data-term="eta conversion">eta conversion<span class="glossary-popup">Substituting functions that simply apply another expression to their argument with the expression in their body. This is a technique in Haskell and Lambda Calculus where a function f x is simplified to f, removing the explicit mention of the parameter when it is not needed.
</span></span>, thus:</p>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span>
<span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">)</span> <span class="n">x</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="p">)</span>             <span class="c1">-- eta conversion</span>
</code></pre></div>  </div>

  <h3 id="compose">Compose</h3>

  <p>Has its own operator in Haskell <code class="language-plaintext highlighter-rouge">(.)</code>, inspired by the mathematical function composition symbol <code class="language-plaintext highlighter-rouge">∘</code>:</p>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">(</span><span class="n">f</span> <span class="err">∘</span> <span class="n">g</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="err">≡</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1">-- math notation</span>
 <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">x</span> <span class="err">≡</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>    <span class="c1">-- Haskell</span>
</code></pre></div>  </div>

  <p>Again, this gives us another way to get the right-most parameter on its own outside the body expression:</p>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span>
<span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span>     <span class="c1">-- operator section</span>
<span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span> <span class="o">.</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">))</span> <span class="n">x</span>   <span class="c1">-- by the definition of composition</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="o">.</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">)</span>         <span class="c1">-- eta conversion</span>
</code></pre></div>  </div>

</div>

<h2 id="point-free-code">Point-Free Code</h2>

<p>We have discussed point-free and tacit coding style earlier in these notes. In particular, eta-conversion works in Haskell the same as in <span class="glossary-term" data-term="lambda calculus">lambda calculus<span class="glossary-popup">A model of computation based on mathematical functions proposed by Alonzo Church in the 1930s.
</span></span> and for curried JavaScript functions.  It is easy to do and usually declutters code of unnecessary arguments, e.g.:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lessThan</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">lessThan</span> <span class="n">n</span> <span class="n">aList</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">n</span><span class="p">)</span> <span class="n">aList</span>
</code></pre></div></div>

<p>The following is more concise, and once you are used to reading Haskell type definitions, just as self-evident:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lessThan</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">lessThan</span> <span class="n">n</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>But the above still has an argument (a point), <code class="language-plaintext highlighter-rouge">n</code>.  Can we go further?</p>

<p>It is possible to be more aggressive in refactoring code to achieve <span class="glossary-term" data-term="point-free style">point-free style<span class="glossary-popup">A way of defining functions without mentioning their arguments.
</span></span> by using the <span class="glossary-term" data-term="compose operator">compose operator<span class="glossary-popup">Represented as (.) in Haskell, it allows the composition of two functions, where the output of the second function is passed as the input to the first function.
</span></span> <code class="language-plaintext highlighter-rouge">(.)</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>To see how to use <code class="language-plaintext highlighter-rouge">(.)</code> in <code class="language-plaintext highlighter-rouge">lessThan</code> we need to refactor it to look like the right-hand side of the definition above, i.e. <code class="language-plaintext highlighter-rouge">f (g x)</code>.  For <code class="language-plaintext highlighter-rouge">lessThan</code>, this takes a couple of steps, because the order we pass arguments to <code class="language-plaintext highlighter-rouge">(&lt;)</code> matters.  Partially applying infix operators like <code class="language-plaintext highlighter-rouge">(&lt;n)</code> is called <span class="glossary-term" data-term="operator sectioning">operator sectioning<span class="glossary-popup">The process of partially applying an infix operator in Haskell by specifying one of its arguments. For example, (+1) is a section of the addition operator with 1 as the second argument.
</span></span>.  Placing <code class="language-plaintext highlighter-rouge">n</code> after <code class="language-plaintext highlighter-rouge">&lt;</code> means that it is being passed as the second argument to the operator, which is inconvenient for eta-conversion.  Observe that <code class="language-plaintext highlighter-rouge">(&lt;n)</code> is equivalent to <code class="language-plaintext highlighter-rouge">(n&gt;)</code>, so the following is equivalent to the definition above:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lessThan</span> <span class="n">n</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>Now we can use the non-infix form of (&gt;):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lessThan</span> <span class="n">n</span> <span class="o">=</span> <span class="n">filter</span> <span class="p">((</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>And we see from <a href="#compose">our definition of compose</a>, that if we were to replace filter by <code class="language-plaintext highlighter-rouge">f</code>, <code class="language-plaintext highlighter-rouge">(&gt;)</code> by <code class="language-plaintext highlighter-rouge">g</code>, and <code class="language-plaintext highlighter-rouge">n</code> by <code class="language-plaintext highlighter-rouge">x</code>, we would have exactly the definition of <code class="language-plaintext highlighter-rouge">(.)</code>.  Thus,</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lessThan</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">filter</span> <span class="o">.</span> <span class="p">(</span><span class="o">&gt;</span><span class="p">))</span> <span class="n">n</span>
</code></pre></div></div>

<p>And now we can apply <a href="#eta-conversion">eta-conversion</a>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lessThan</span> <span class="o">=</span> <span class="n">filter</span> <span class="o">.</span> <span class="p">(</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div></div>

<p>Between <span class="glossary-term" data-term="operator sectioning">operator sectioning<span class="glossary-popup">The process of partially applying an infix operator in Haskell by specifying one of its arguments. For example, (+1) is a section of the addition operator with 1 as the second argument.
</span></span>, the compose <span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> <code class="language-plaintext highlighter-rouge">(.)</code>, and eta-conversion it is possible to write many functions in point-free form.  For example, the flip <span class="glossary-term" data-term="combinator">combinator<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flip</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">flip</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">a</span>
</code></pre></div></div>

<p>can also be useful in reversing the arguments of a function or operator in order to get them into a position such that they can be eta-reduced.</p>

<p>In code written by experienced Haskellers it is very common to see functions reduced to point-free form.  Does it make code more readable?  To experienced Haskellers, many times yes.  To novices, perhaps not.  When to do it is a matter of preference.  Experienced Haskellers tend to prefer it: they will argue that it reduces functions like the example one above “to their essence”, removing the “unnecessary plumbing” of explicitly named variables.   Whether you like it or not, it is worth being familiar with the tricks above, because you will undoubtedly see them used in practice.  The other place where <span class="glossary-term" data-term="point-free style">point-free style<span class="glossary-popup">A way of defining functions without mentioning their arguments.
</span></span> is very useful is when you would otherwise need to use a lambda function.</p>

<p>Some more (and deeper) discussion is available on the Haskell Wiki.</p>

<hr>

<h3 id="exercises">Exercises</h3>

<ul>
  <li>Refactor the following functions to be point-free. These are clearly extreme examples but is a useful—and easily verified—practice of <span class="glossary-term" data-term="operator sectioning">operator sectioning<span class="glossary-popup">The process of partially applying an infix operator in Haskell by specifying one of its arguments. For example, (+1) is a section of the addition operator with 1 as the second argument.
</span></span>, composition and eta-conversion.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
</code></pre></div></div>

<p><strong>Extension: Warning, this one scary</strong>
This is very non-assessable, and no one will ask anything harder then first two questions</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span>
</code></pre></div></div>

<div class="solutions">
    
<h4 id="solutions">Solutions</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">g</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="n">y</span> <span class="c1">-- operator sectioning</span>
<span class="n">g</span> <span class="n">x</span>   <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="c1">-- eta conversion</span>
<span class="n">g</span> <span class="n">x</span>   <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">((</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="n">x</span><span class="p">)</span> <span class="c1">-- operator sectioning</span>
<span class="n">g</span> <span class="n">x</span>   <span class="o">=</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="n">x</span> <span class="c1">-- composition</span>
<span class="n">g</span>     <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="c1">-- eta conversion</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="n">c</span> <span class="c1">-- operator sectioning</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span>   <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- eta conversion</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span>   <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="o">+</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- operator sectioning</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span>   <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="p">)</span> <span class="o">.</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="n">a</span><span class="p">))</span> <span class="n">b</span> <span class="c1">-- composition</span>
<span class="n">f</span> <span class="n">a</span>     <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">.</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- eta conversion</span>
<span class="n">f</span> <span class="n">a</span>     <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="p">)</span> <span class="o">.</span><span class="p">)</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
<span class="n">f</span> <span class="n">a</span>     <span class="o">=</span> <span class="p">(((</span><span class="o">*</span><span class="p">)</span> <span class="o">.</span> <span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="p">))</span> <span class="n">a</span> <span class="c1">-- composition</span>
<span class="n">f</span>       <span class="o">=</span> <span class="p">((</span><span class="o">*</span><span class="p">)</span> <span class="o">.</span> <span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="c1">-- eta conversion</span>
</code></pre></div></div>

<p>Only look at this one if you are curious (very non-assessable, and no one will ask anything harder then first two questions)</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>Where do we go from here?
We need a function which applies the <code class="language-plaintext highlighter-rouge">*</code> function to the same argument <code class="language-plaintext highlighter-rouge">b</code>
Let’s invent one:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apply</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">apply</span> <span class="n">f</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span> <span class="n">b</span> <span class="n">b</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- using our apply function</span>
<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">))</span> <span class="p">((</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- this is in the form f (g x), where f == ((+) (apply (*) a)) and g == (apply (*))</span>

<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">b</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span>

<span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(((</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">))</span> <span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)))</span> <span class="n">b</span> <span class="c1">-- apply function composition</span>
<span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">))</span> <span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span> <span class="c1">-- eta conversion</span>
<span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)))</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="p">))</span>  <span class="c1">-- operator sectioning</span>
<span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)))</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- composition inside brackets ((+) (apply (*) a))</span>
<span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)))</span> <span class="o">.</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)))</span> <span class="n">a</span> <span class="c1">-- composition</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)))</span> <span class="o">.</span> <span class="p">((</span><span class="o">+</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)))</span> <span class="c1">-- eta conversion</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span> <span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">))</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">.</span> <span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="c1">-- simplify brackets</span>
</code></pre></div></div>


</div>

<hr>

<h2 id="functor">Functor</h2>

<p>We’ve been mapping over lists and arrays many times, first in JavaScript:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nf">map</span><span class="p">(</span><span class="nx">x</span><span class="o">=&gt;</span><span class="nx">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>Now in Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>Or (eta-reduce the lambda to be point-free):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>Here’s the implementation of <code class="language-plaintext highlighter-rouge">map</code> for lists as it’s <a href="http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Base.html#map">defined in the GHC standard library</a>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">map</span> <span class="kr">_</span> <span class="kt">[]</span>     <span class="o">=</span> <span class="kt">[]</span>
<span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</code></pre></div></div>

<p>It’s easy to generalise this pattern to any data structure that holds one or more values: mapping a function over a data structure creates a new data structure whose elements are the result of applying the function to the elements of the original data structure. We have seen examples of generalising the idea of mapping previously, for example, mapping over a <code class="language-plaintext highlighter-rouge">Tree</code>.</p>

<p>In Haskell this pattern is captured in a <span class="glossary-term" data-term="type class">type class<span class="glossary-popup">A type system construct in Haskell that defines a set of functions that can be applied to different types, allowing for polymorphic functions.
</span></span> called <a href="/assets/WhatTheFunctor.mp3"><code class="language-plaintext highlighter-rouge">Functor</code></a>, which defines a function called <code class="language-plaintext highlighter-rouge">fmap</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">Functor</span>
<span class="kr">type</span> <span class="kt">Functor</span> <span class="o">::</span> <span class="p">(</span><span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Constraint</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="c1">-- naturally lists are an instance</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="c1">-- but this may surprise!</span>
<span class="o">...</span> <span class="c1">-- and some other instances we’ll talk about shortly</span>
</code></pre></div></div>

<p>The first line says that an instance of the <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> typeclass <code class="language-plaintext highlighter-rouge">f</code> must be over a type that has the <a href="/haskell2#type-kinds">kind</a> <code class="language-plaintext highlighter-rouge">(* -&gt; *)</code>, that is, their constructors must be parameterised with a single type variable.  After this, the <code class="language-plaintext highlighter-rouge">class</code> definition specifies <code class="language-plaintext highlighter-rouge">fmap</code> as a function that will be available to any instance of <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> and that <code class="language-plaintext highlighter-rouge">f</code> is the <span class="glossary-term" data-term="type parameter">type parameter<span class="glossary-popup">A placeholder for a type that is specified when a generic function or class is used, allowing for type-safe but flexible code.
</span></span> for the constructor function, which again, takes one <span class="glossary-term" data-term="type parameter">type parameter<span class="glossary-popup">A placeholder for a type that is specified when a generic function or class is used, allowing for type-safe but flexible code.
</span></span>, e.g. <code class="language-plaintext highlighter-rouge">f a</code> as the input to <code class="language-plaintext highlighter-rouge">fmap</code>, which returns an <code class="language-plaintext highlighter-rouge">f b</code>. While this may sound complex and abstract, the power of <code class="language-plaintext highlighter-rouge">fmap</code> is just applying the idea of a <code class="language-plaintext highlighter-rouge">map</code> function to any collection of item(s).</p>

<p>Naturally, lists have an instance:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">[]</span>
<span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="c1">-- Defined in `GHC.Base'</span>
</code></pre></div></div>

<p>We can actually look up GHC’s implementation of <code class="language-plaintext highlighter-rouge">fmap</code> for lists and we see:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="o">=</span> <span class="n">map</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">fmap</code> is defined for other types we have seen, such as a <code class="language-plaintext highlighter-rouge">Maybe</code>. <code class="language-plaintext highlighter-rouge">Maybes</code> can be considered as a list of 0 items (<code class="language-plaintext highlighter-rouge">Nothing</code>) or 1 item (<code class="language-plaintext highlighter-rouge">Just</code>), and therefore, naturally, we should be able to <code class="language-plaintext highlighter-rouge">fmap</code> over a <code class="language-plaintext highlighter-rouge">Maybe</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span>  <span class="kt">Functor</span> <span class="kt">Maybe</span>  <span class="kr">where</span>
    <span class="n">fmap</span> <span class="kr">_</span> <span class="kt">Nothing</span>       <span class="o">=</span> <span class="kt">Nothing</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span>      <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>We can use <code class="language-plaintext highlighter-rouge">fmap</code> to apply a function to a <code class="language-plaintext highlighter-rouge">Maybe</code> value without needing to unpack it. The true power of <code class="language-plaintext highlighter-rouge">fmap</code> lies in its ability to apply a function to value(s) within a context without requiring knowledge of how to extract those values from the context.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">7</span>
</code></pre></div></div>

<p>This is such a common operation that there is an operator alias for fmap: <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">7</span>
</code></pre></div></div>

<p>Which also works over lists:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>Lists of <code class="language-plaintext highlighter-rouge">Maybe</code>s frequently arise.  For example, the <code class="language-plaintext highlighter-rouge">mod</code> operation on integers (e.g. <code class="language-plaintext highlighter-rouge">mod 3 2 == 1</code>) will throw an error if you pass 0 as the divisor:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">mod</span> <span class="mi">3</span> <span class="mi">0</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">divide</span> <span class="n">by</span> <span class="n">zero</span>
</code></pre></div></div>

<p>We might define a safe modulo function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">safeMod</span> <span class="o">::</span> <span class="kt">Integral</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span><span class="o">-&gt;</span> <span class="n">a</span><span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">safeMod</span> <span class="kr">_</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">safeMod</span> <span class="n">numerator</span> <span class="n">divisor</span> <span class="o">=</span> <span class="kt">Just</span> <span class="o">$</span> <span class="n">mod</span> <span class="n">numerator</span> <span class="n">divisor</span>
</code></pre></div></div>

<p>This makes it safe to apply <code class="language-plaintext highlighter-rouge">safeMod</code> to an arbitrary list of <code class="language-plaintext highlighter-rouge">Integral</code> values:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">safeMod</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">0</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<p>But how do we keep working with such a list of <code class="language-plaintext highlighter-rouge">Maybe</code>s?  We can map an <code class="language-plaintext highlighter-rouge">fmap</code> over the list:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">((</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="p">[</span><span class="kt">Just</span> <span class="mi">0</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">2</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>Or equivalently:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="p">((</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="kt">Just</span> <span class="mi">0</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">2</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>In addition to lists and <code class="language-plaintext highlighter-rouge">Maybe</code>s, a number of other built-in types have instances of <code class="language-plaintext highlighter-rouge">Functor</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">Functor</span>
<span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in `Data.Either'</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="c1">-- Defined in `GHC.Base'</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="c1">-- Defined in `GHC.Base'</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((,)</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- Defined in `GHC.Base'</span>
</code></pre></div></div>

<p>The definition for functions <code class="language-plaintext highlighter-rouge">(-&gt;)</code> might surprise:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="o">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>
</code></pre></div></div>

<p>So the composition of functions <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code>, <code class="language-plaintext highlighter-rouge">f . g</code>, is equivalent to “mapping” <code class="language-plaintext highlighter-rouge">f</code> over <code class="language-plaintext highlighter-rouge">g</code>, e.g.  <code class="language-plaintext highlighter-rouge">f &lt;$&gt; g</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="kt">GHCi</span><span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="kt">GHCi</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">g</span><span class="p">)</span> <span class="mi">3</span>
<span class="mi">7</span>
<span class="kt">GHCi</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">f</span><span class="o">&lt;$&gt;</span><span class="n">g</span><span class="p">)</span> <span class="mi">3</span>
<span class="mi">7</span>
</code></pre></div></div>

<h3 id="functor-laws">Functor Laws</h3>

<p>We can formalise the definition of <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> with two laws:</p>

<p>The law of <strong><em>identity</em></strong></p>

<p>∀ x: (id &lt;\$&gt; x) ≡ x</p>

<p>The law of <strong><em>composition</em></strong></p>

<p>∀ f, g, x: (f ∘ g &lt;\$&gt; x) ≡ (f &lt;\$&gt; (g &lt;\$&gt; x))</p>

<p>(∘ has higher precedence than &lt;\$&gt;, so f ∘ g &lt;\$&gt; x is equal to (f ∘ g) &lt;\$&gt; x.)</p>

<p>Note that these laws are not enforced by the compiler when you create your own instances of <code class="language-plaintext highlighter-rouge">Functor</code>.  You’ll need to test them for yourself.  Following these laws guarantees that general code (e.g. algorithms) using <code class="language-plaintext highlighter-rouge">fmap</code> will also work for your own instances of <code class="language-plaintext highlighter-rouge">Functor</code>.</p>

<p>Let’s make a custom instance of <code class="language-plaintext highlighter-rouge">Functor</code> for a simple binary tree type and check that the laws hold.  Here’s a simple binary tree data type:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Empty</span>
            <span class="o">|</span> <span class="kt">Leaf</span> <span class="n">a</span>
            <span class="o">|</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">Leaf</code> is a bit redundant as we could also encode nodes with no children as <code class="language-plaintext highlighter-rouge">Node Empty value Empty</code>—but that’s kind of ugly and makes showing our trees more verbose.  Also, having both <code class="language-plaintext highlighter-rouge">Leaf</code> and <code class="language-plaintext highlighter-rouge">Empty</code> provides a nice parallel to <code class="language-plaintext highlighter-rouge">Maybe</code>.</p>

<p>Here’s an example tree defined:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tree</span> <span class="o">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">3</span><span class="p">))</span> <span class="mi">4</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">6</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">7</span><span class="p">))</span>
</code></pre></div></div>

<p>And here’s a visualisation of the tree:</p>

<pre><code class="language-pseudocode">Node 4
 ├──Node 2
 |   ├──Leaf 1
 |   └──Leaf 3
 └──Node 6
     ├──Leaf 5
     └──Leaf 7
</code></pre>

<p>And here’s the instance of <code class="language-plaintext highlighter-rouge">Functor</code> for <code class="language-plaintext highlighter-rouge">Tree</code> that defines <code class="language-plaintext highlighter-rouge">fmap</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Tree</span> <span class="kr">where</span>
   <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Tree</span> <span class="n">b</span>
   <span class="n">fmap</span> <span class="kr">_</span> <span class="kt">Empty</span> <span class="o">=</span> <span class="kt">Empty</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Leaf</span> <span class="o">$</span> <span class="n">f</span> <span class="n">v</span>
   <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">l</span> <span class="n">v</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">v</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<p>Just as in the <code class="language-plaintext highlighter-rouge">Maybe</code> instance above, we use <span class="glossary-term" data-term="pattern matching">pattern matching<span class="glossary-popup">A mechanism in functional programming languages to check a value against a pattern and to deconstruct data.
</span></span> to define a case for each possible constructor in the ADT.  The <code class="language-plaintext highlighter-rouge">Empty</code> and <code class="language-plaintext highlighter-rouge">Leaf</code> cases are very similar to <code class="language-plaintext highlighter-rouge">Maybe</code> <code class="language-plaintext highlighter-rouge">fmap</code> for <code class="language-plaintext highlighter-rouge">Nothing</code> and <code class="language-plaintext highlighter-rouge">Just</code> respectively, that is, for <code class="language-plaintext highlighter-rouge">Empty</code> we just return another <code class="language-plaintext highlighter-rouge">Empty</code>, for <code class="language-plaintext highlighter-rouge">Leaf</code> we return a new <code class="language-plaintext highlighter-rouge">Leaf</code> containing the application of <code class="language-plaintext highlighter-rouge">f</code> to the value <code class="language-plaintext highlighter-rouge">x</code> stored in the leaf.  The fun one is <code class="language-plaintext highlighter-rouge">Node</code>.  As for <code class="language-plaintext highlighter-rouge">Leaf</code>, <code class="language-plaintext highlighter-rouge">fmap f</code> of a <code class="language-plaintext highlighter-rouge">Node</code> returns a new <code class="language-plaintext highlighter-rouge">Node</code> whose own value is the result of applying <code class="language-plaintext highlighter-rouge">f</code> to the value stored in the input <code class="language-plaintext highlighter-rouge">Node</code>, but the left and right children of the new node will be the recursive application of <code class="language-plaintext highlighter-rouge">fmap f</code> to the children of the input node.</p>

<p>Now we’ll demonstrate (but not prove) that the two laws hold at least for our example tree:</p>

<p>Law of Identity:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">id</span> <span class="o">&lt;$&gt;</span> <span class="n">tree</span>
<span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">3</span><span class="p">))</span> <span class="mi">4</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">5</span><span class="p">)</span> <span class="mi">6</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">7</span><span class="p">))</span>
</code></pre></div></div>

<p>Law of Composition:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">((</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">tree</span><span class="p">)</span>
<span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">7</span><span class="p">))</span> <span class="mi">9</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">11</span><span class="p">)</span> <span class="mi">13</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">15</span><span class="p">))</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">tree</span>
<span class="kt">Node</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">7</span><span class="p">))</span> <span class="mi">9</span> <span class="p">(</span><span class="kt">Node</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">11</span><span class="p">)</span> <span class="mi">13</span> <span class="p">(</span><span class="kt">Leaf</span> <span class="mi">15</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="applicative">Applicative</h2>

<p>The typeclass <code class="language-plaintext highlighter-rouge">Applicative</code> introduces a new operator <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> (pronounced “apply”), which lets us apply functions inside a computational context.</p>

<p><span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> is a “subclass” of <code class="language-plaintext highlighter-rouge">Functor</code>, meaning that an instance of <code class="language-plaintext highlighter-rouge">Applicative</code> can be <code class="language-plaintext highlighter-rouge">fmap</code>ed over, but <span class="glossary-term" data-term="applicatives">Applicatives<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> also declare (at least) two additional functions, <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">(&lt;*&gt;)</code> (pronounced “apply”—but I like calling it <a href="https://en.wikipedia.org/wiki/TIE_fighter">“TIE Fighter”</a>):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">Applicative</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="n">f</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>As for <code class="language-plaintext highlighter-rouge">Functor</code> all instances of the <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> type-class must satisfy certain laws, which again are not checked by the compiler.
<span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> instances must comply with these laws to produce the expected behaviour.
You can <a href="https://en.wikibooks.org/wiki/Haskell/Applicative_functors">read about the <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> Laws</a>
if you are interested, but they are a little more subtle than the basic <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> laws above, and it is
not essential to understand them to be able to use <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> in Haskell.</p>

<p>As for <code class="language-plaintext highlighter-rouge">Functor</code>, many Base Haskell types are also <code class="language-plaintext highlighter-rouge">Applicative</code>, e.g. <code class="language-plaintext highlighter-rouge">[]</code>, <code class="language-plaintext highlighter-rouge">Maybe</code>, <code class="language-plaintext highlighter-rouge">IO</code> and <code class="language-plaintext highlighter-rouge">(-&gt;)</code>.</p>

<p>For example, a function inside a <code class="language-plaintext highlighter-rouge">Maybe</code> can be applied to a value in a <code class="language-plaintext highlighter-rouge">Maybe</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">Just</span> <span class="mi">5</span>
</code></pre></div></div>

<p>Or a list of functions <code class="language-plaintext highlighter-rouge">[(+1),(+2)]</code> to things inside a similar context (e.g. a list <code class="language-plaintext highlighter-rouge">[1,2,3]</code>).</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[(</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="o">+</span><span class="mi">2</span><span class="p">)]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div></div>

<p>Note that list’s definition of <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> produces the Cartesian product of the two lists, that is, all the possible ways to apply the functions in the left list to the values in the right list.  It is interesting to look at <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.Base.html#Applicative">the source</a> for the definition of <code class="language-plaintext highlighter-rouge">Applicative</code> for lists on Hackage:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="n">x</span>    <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="o">|</span> <span class="n">f</span> <span class="o">&lt;-</span> <span class="n">fs</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>  <span class="c1">-- list comprehension</span>
</code></pre></div></div>

<p>The definition of <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> for lists uses a list comprehension.  List comprehensions are a short-hand way to generate lists, using notation similar to mathematical <a href="https://en.wikipedia.org/wiki/Set-builder_notation">“set builder notation”</a>.  The set builder notation here would be:  <code class="language-plaintext highlighter-rouge">{f(x) |  f ∈ fs ∧ x ∈ xs}</code>.  In English it means: “the set (Haskell list) of all functions in <code class="language-plaintext highlighter-rouge">fs</code> applied to all values in <code class="language-plaintext highlighter-rouge">xs</code>”.</p>

<p>A common use-case for <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> is applying a binary (two-parameter) function over two <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> values, e.g.:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">Just</span> <span class="mi">5</span>
</code></pre></div></div>

<p>So:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pure</code> puts the binary function into the <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> (i.e. <code class="language-plaintext highlighter-rouge">pure (+) :: Maybe (Num -&gt; Num -&gt; Num)</code>),</li>
  <li>then <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>ing this function inside over the first <code class="language-plaintext highlighter-rouge">Maybe</code> value <code class="language-plaintext highlighter-rouge">Just 3</code> achieves a <span class="glossary-term" data-term="partial application">partial application<span class="glossary-popup">The process of fixing a number of arguments to a function, producing another function of smaller arity.
</span></span> of the function inside the <code class="language-plaintext highlighter-rouge">Maybe</code>. This gives a unary function inside a <code class="language-plaintext highlighter-rouge">Maybe</code>: i.e. <code class="language-plaintext highlighter-rouge">Just (3+) :: Maybe (Num-&gt;Num)</code>.</li>
  <li>Finally, we <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> this function inside a <code class="language-plaintext highlighter-rouge">Maybe</code> over the remaining <code class="language-plaintext highlighter-rouge">Maybe</code> value.</li>
</ul>

<p>This is where the name “<span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>” comes from, i.e. <code class="language-plaintext highlighter-rouge">Applicative</code> is a type over which a non-unary function may be applied.  Note that the following use of <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> (infix <code class="language-plaintext highlighter-rouge">fmap</code>) is equivalent and a little bit more concise:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">Just</span> <span class="mi">5</span>
</code></pre></div></div>

<p>This is also called “<span class="glossary-term" data-term="lifting">lifting<span class="glossary-popup">The process of applying a function to arguments that are within a context, such as a Functor or Applicative.
</span></span>” a function over an <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>.  Actually, it’s so common that <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> also defines dedicated functions for <span class="glossary-term" data-term="lifting">lifting<span class="glossary-popup">The process of applying a function to arguments that are within a context, such as a Functor or Applicative.
</span></span> binary functions (in the GHC.Base module):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">GHC</span><span class="o">.</span><span class="kt">Base</span><span class="o">.</span><span class="n">liftA2</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">2</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">5</span>
</code></pre></div></div>

<p>Here’s a little visual summary of <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> and <span class="glossary-term" data-term="lifting">lifting<span class="glossary-popup">The process of applying a function to arguments that are within a context, such as a Functor or Applicative.
</span></span> (box metaphor inspired by <a href="http://www.adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">adit.io</a>):</p>

<p><img src="/assets/images/chapterImages/haskell3/applicativePicture.png" alt="Applicative Visual Summary"></p>

<p>It’s also useful to lift binary data constructors over two <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> values, e.g. for tuples:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">Just</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>We can equally well apply functions with more than two arguments over the correct number of values inside <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> contexts.
Recall our student data type:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Student</span> <span class="o">=</span> <span class="kt">Student</span> <span class="p">{</span> <span class="n">id</span><span class="o">::</span><span class="kt">Integer</span><span class="p">,</span> <span class="n">name</span><span class="o">::</span><span class="kt">String</span><span class="p">,</span> <span class="n">mark</span><span class="o">::</span><span class="kt">Int</span> <span class="p">}</span>
</code></pre></div></div>

<p>with a ternary constructor:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Student</span><span class="o">::</span><span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Student</span>
</code></pre></div></div>

<p>Let’s say we want to create a student for a given <code class="language-plaintext highlighter-rouge">id</code> but we need to look up the name and mark from tables, i.e. lists of key-value pairs:
<code class="language-plaintext highlighter-rouge">names::[(Integer,String)]</code> and <code class="language-plaintext highlighter-rouge">marks::[(Integer,Int)]</code>.  We’ll use the function <code class="language-plaintext highlighter-rouge">lookup :: Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b</code>, which will either succeed with <code class="language-plaintext highlighter-rouge">Just</code> the result, or fail to find the value for a given key, and return <code class="language-plaintext highlighter-rouge">Nothing</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lookupStudent</span> <span class="o">::</span> <span class="kt">Integer</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Student</span>
<span class="n">lookupStudent</span> <span class="n">sid</span> <span class="o">=</span> <span class="kt">Student</span> <span class="n">sid</span> <span class="o">&lt;$&gt;</span> <span class="n">lookup</span> <span class="n">sid</span> <span class="n">names</span> <span class="o">&lt;*&gt;</span> <span class="n">lookup</span> <span class="n">sid</span> <span class="n">marks</span>
</code></pre></div></div>

<!-- The following example doesn’t typecheck. Commented it out for now.

What if `sid` is also the result of some computation that may fail, and is therefore itself wrapped in a `Maybe` context?  Then we will need to apply the ternary `Student` constructor over three `Maybe`s:

```haskell
lookupStudent :: Maybe Integer -> Maybe Student
lookupStudent sid = Student <$> sid <*> lookup sid names <*> lookup sid marks
```

So we can see `<*>` may be chained as many times as necessary to cover all the arguments.
-->

<p>Lists are also instances of <code class="language-plaintext highlighter-rouge">Applicative</code>.  Given the following types:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Suit</span> <span class="o">=</span> <span class="kt">Spade</span><span class="o">|</span><span class="kt">Club</span><span class="o">|</span><span class="kt">Diamond</span><span class="o">|</span><span class="kt">Heart</span>
 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Ord</span><span class="p">,</span><span class="kt">Enum</span><span class="p">,</span><span class="kt">Bounded</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Suit</span> <span class="kr">where</span>
 <span class="n">show</span> <span class="kt">Spade</span> <span class="o">=</span> <span class="s">"^"</span>     <span class="c1">-- ♠  (closest I could come in ASCII was ^)</span>
 <span class="n">show</span> <span class="kt">Club</span> <span class="o">=</span> <span class="s">"&amp;"</span>      <span class="c1">-- ♣</span>
 <span class="n">show</span> <span class="kt">Diamond</span> <span class="o">=</span> <span class="s">"O"</span>   <span class="c1">-- ♦</span>
 <span class="n">show</span> <span class="kt">Heart</span> <span class="o">=</span> <span class="s">"V"</span>     <span class="c1">-- ♥</span>

<span class="kr">data</span> <span class="kt">Rank</span> <span class="o">=</span> <span class="kt">Two</span><span class="o">|</span><span class="kt">Three</span><span class="o">|</span><span class="kt">Four</span><span class="o">|</span><span class="kt">Five</span><span class="o">|</span><span class="kt">Six</span><span class="o">|</span><span class="kt">Seven</span><span class="o">|</span><span class="kt">Eight</span><span class="o">|</span><span class="kt">Nine</span><span class="o">|</span><span class="kt">Ten</span><span class="o">|</span><span class="kt">Jack</span><span class="o">|</span><span class="kt">Queen</span><span class="o">|</span><span class="kt">King</span><span class="o">|</span><span class="kt">Ace</span>
 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span><span class="kt">Ord</span><span class="p">,</span><span class="kt">Enum</span><span class="p">,</span><span class="kt">Show</span><span class="p">,</span><span class="kt">Bounded</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Card</span> <span class="o">=</span> <span class="kt">Card</span> <span class="kt">Suit</span> <span class="kt">Rank</span>
 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</code></pre></div></div>

<p>We can make one card using the Card constructor:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="kt">Card</span> <span class="kt">Spade</span> <span class="kt">Ace</span>
<span class="kt">Card</span> <span class="o">^</span> <span class="kt">Ace</span>
</code></pre></div></div>

<p>Or, since both <code class="language-plaintext highlighter-rouge">Suit</code> and <code class="language-plaintext highlighter-rouge">Rank</code> derive <code class="language-plaintext highlighter-rouge">Enum</code>, we can enumerate the full lists of <code class="language-plaintext highlighter-rouge">Suit</code>s and <code class="language-plaintext highlighter-rouge">Rank</code>s, and then lift the <code class="language-plaintext highlighter-rouge">Card</code> operator over both lists to create a whole deck:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">GHCi</span><span class="o">&gt;</span> <span class="kt">Card</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="kt">Spade</span> <span class="o">..</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="kt">Two</span> <span class="o">..</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Two</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Three</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Four</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Five</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Six</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Seven</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Eight</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Nine</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Ten</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Jack</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Queen</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">King</span><span class="p">,</span><span class="kt">Card</span> <span class="o">^</span> <span class="kt">Ace</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Two</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Three</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Four</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Five</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Six</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Seven</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Eight</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Nine</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Ten</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Jack</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Queen</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">King</span><span class="p">,</span><span class="kt">Card</span> <span class="o">&amp;</span> <span class="kt">Ace</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Two</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Three</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Four</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Five</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Six</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Seven</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Eight</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Nine</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Ten</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Jack</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Queen</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">King</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">O</span> <span class="kt">Ace</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Two</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Three</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Four</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Five</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Six</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Seven</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Eight</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Nine</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Ten</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Jack</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Queen</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">King</span><span class="p">,</span><span class="kt">Card</span> <span class="kt">V</span> <span class="kt">Ace</span><span class="p">]</span>
</code></pre></div></div>

<hr>

<h3 id="exercise">Exercise</h3>

<ul>
  <li>Create instances of <code class="language-plaintext highlighter-rouge">Show</code> for <code class="language-plaintext highlighter-rouge">Rank</code> and <code class="language-plaintext highlighter-rouge">Card</code> such that a deck of cards displays much more succinctly, e.g.:</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span><span class="o">^</span><span class="mi">3</span><span class="p">,</span><span class="o">^</span><span class="mi">4</span><span class="p">,</span><span class="o">^</span><span class="mi">5</span><span class="p">,</span><span class="o">^</span><span class="mi">6</span><span class="p">,</span><span class="o">^</span><span class="mi">7</span><span class="p">,</span><span class="o">^</span><span class="mi">8</span><span class="p">,</span><span class="o">^</span><span class="mi">9</span><span class="p">,</span><span class="o">^</span><span class="mi">10</span><span class="p">,</span><span class="o">^</span><span class="kt">J</span><span class="p">,</span><span class="o">^</span><span class="kt">Q</span><span class="p">,</span><span class="o">^</span><span class="kt">K</span><span class="p">,</span><span class="o">^</span><span class="kt">A</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">2</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">3</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">4</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">5</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">6</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">8</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">9</span><span class="p">,</span><span class="o">&amp;</span><span class="mi">10</span><span class="p">,</span><span class="o">&amp;</span><span class="kt">J</span><span class="p">,</span><span class="o">&amp;</span><span class="kt">Q</span><span class="p">,</span><span class="o">&amp;</span><span class="kt">K</span><span class="p">,</span><span class="o">&amp;</span><span class="kt">A</span><span class="p">,</span><span class="kt">O2</span><span class="p">,</span><span class="kt">O3</span><span class="p">,</span><span class="kt">O4</span><span class="p">,</span><span class="kt">O5</span><span class="p">,</span><span class="kt">O6</span><span class="p">,</span><span class="kt">O7</span><span class="p">,</span><span class="kt">O8</span><span class="p">,</span><span class="kt">O9</span><span class="p">,</span><span class="kt">O10</span><span class="p">,</span><span class="kt">OJ</span><span class="p">,</span><span class="kt">OQ</span><span class="p">,</span><span class="kt">OK</span><span class="p">,</span><span class="kt">OA</span><span class="p">,</span><span class="kt">V2</span><span class="p">,</span><span class="kt">V3</span><span class="p">,</span><span class="kt">V4</span><span class="p">,</span><span class="kt">V5</span><span class="p">,</span><span class="kt">V6</span><span class="p">,</span><span class="kt">V7</span><span class="p">,</span><span class="kt">V8</span><span class="p">,</span><span class="kt">V9</span><span class="p">,</span><span class="kt">V10</span><span class="p">,</span><span class="kt">VJ</span><span class="p">,</span><span class="kt">VQ</span><span class="p">,</span><span class="kt">VK</span><span class="p">,</span><span class="kt">VA</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li>Try and make the definition of <code class="language-plaintext highlighter-rouge">show</code> for <code class="language-plaintext highlighter-rouge">Rank</code> a one-liner using <code class="language-plaintext highlighter-rouge">zip</code> and <code class="language-plaintext highlighter-rouge">lookup</code>.</li>
</ul>

<div class="solutions">
    
<h4 id="solutions">Solutions</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Suit</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Spade</span> <span class="o">=</span> <span class="s">"^"</span>     <span class="c1">-- Represents Spades</span>
    <span class="n">show</span> <span class="kt">Club</span> <span class="o">=</span> <span class="s">"&amp;"</span>      <span class="c1">-- Represents Clubs</span>
    <span class="n">show</span> <span class="kt">Diamond</span> <span class="o">=</span> <span class="s">"O"</span>   <span class="c1">-- Represents Diamonds</span>
    <span class="n">show</span> <span class="kt">Heart</span> <span class="o">=</span> <span class="s">"V"</span>     <span class="c1">-- Represents Hearts</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Rank</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Two</span> <span class="o">=</span> <span class="s">"2"</span>
    <span class="n">show</span> <span class="kt">Three</span> <span class="o">=</span> <span class="s">"3"</span>
    <span class="n">show</span> <span class="kt">Four</span> <span class="o">=</span> <span class="s">"4"</span>
    <span class="n">show</span> <span class="kt">Five</span> <span class="o">=</span> <span class="s">"5"</span>
    <span class="n">show</span> <span class="kt">Six</span> <span class="o">=</span> <span class="s">"6"</span>
    <span class="n">show</span> <span class="kt">Seven</span> <span class="o">=</span> <span class="s">"7"</span>
    <span class="n">show</span> <span class="kt">Eight</span> <span class="o">=</span> <span class="s">"8"</span>
    <span class="n">show</span> <span class="kt">Nine</span> <span class="o">=</span> <span class="s">"9"</span>
    <span class="n">show</span> <span class="kt">Ten</span> <span class="o">=</span> <span class="s">"10"</span>
    <span class="n">show</span> <span class="kt">Jack</span> <span class="o">=</span> <span class="s">"J"</span>
    <span class="n">show</span> <span class="kt">Queen</span> <span class="o">=</span> <span class="s">"Q"</span>
    <span class="n">show</span> <span class="kt">King</span> <span class="o">=</span> <span class="s">"K"</span>
    <span class="n">show</span> <span class="kt">Ace</span> <span class="o">=</span> <span class="s">"A"</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Card</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="p">(</span><span class="kt">Card</span> <span class="n">s</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">show</span> <span class="n">s</span> <span class="o">++</span> <span class="n">show</span> <span class="n">r</span>
</code></pre></div></div>

<p>To define the show method for Rank as a one-liner using <code class="language-plaintext highlighter-rouge">zip</code> and <code class="language-plaintext highlighter-rouge">lookup</code>, we can leverage these functions to directly map the Rank constructors to their respective string representations.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Rank</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fromMaybe</span> <span class="s">""</span> <span class="o">$</span> <span class="n">lookup</span> <span class="n">r</span> <span class="p">(</span><span class="n">zip</span> <span class="p">[</span><span class="kt">Two</span> <span class="o">..</span> <span class="kt">Ace</span><span class="p">]</span> <span class="p">[</span><span class="s">"2"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">,</span> <span class="s">"4"</span><span class="p">,</span> <span class="s">"5"</span><span class="p">,</span> <span class="s">"6"</span><span class="p">,</span> <span class="s">"7"</span><span class="p">,</span> <span class="s">"8"</span><span class="p">,</span> <span class="s">"9"</span><span class="p">,</span> <span class="s">"10"</span><span class="p">,</span> <span class="s">"J"</span><span class="p">,</span> <span class="s">"Q"</span><span class="p">,</span> <span class="s">"K"</span><span class="p">,</span> <span class="s">"A"</span><span class="p">])</span>
</code></pre></div></div>


</div>

<h2 id="equivalent-definition-of-applicative">Equivalent Definition of Applicative</h2>

<p>Feel free to skip this definition if the previous one made sense. But, here is an <span class="glossary-term" data-term="alternative">alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> definition if it helps you.</p>

<p>There is an <span class="glossary-term" data-term="alternative">alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> way to think about <span class="glossary-term" data-term="applicatives">applicatives<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>, which highlights (arguably) the main usage of <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">pure</span>   <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="n">liftA2</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
</code></pre></div></div>

<p>This definition says: we’re extending the idea of <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> (which allows you to apply a one-argument function to a value in a context) to two-argument functions.</p>

<p>Recall that:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">liftA2</code> is just the natural next step in this pattern.</p>

<p>For example, here’s the instance for <code class="language-plaintext highlighter-rouge">Maybe</code>, which follows the same pattern as <code class="language-plaintext highlighter-rouge">fmap</code>, just extended to two inputs:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="o">=</span> <span class="kt">Just</span>
  <span class="n">liftA2</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
  <span class="n">liftA2</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">Applicative</code> gives us the power to apply two arguments in context to a function. Since we have two, we can also extend this to three, but we don’t need a new mechanism: we can keep applying functions to multiple arguments by combining <code class="language-plaintext highlighter-rouge">liftA2</code> in a nested way. In other words, once we’ve applied a function to two contextual values using <code class="language-plaintext highlighter-rouge">liftA2</code>, the result is a new function still inside the context, and we can use liftA2 again to apply that to a third value — and so on.</p>

<h3 id="can-we-recover-the-tie-fighter-from-lifta2">Can we recover the tie-fighter from liftA2?</h3>

<p>We can define <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> using <code class="language-plaintext highlighter-rouge">liftA2</code>, we can rephrase the <code class="language-plaintext highlighter-rouge">Applicative</code> definition like this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Default implementation of &lt;*&gt;</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="n">ff</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="n">ff</span> <span class="n">fa</span>
</code></pre></div></div>

<p>Let’s unpack it:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ff</code> is a function inside a context (i.e., <code class="language-plaintext highlighter-rouge">Just (+1)</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">fa</code> is a value inside a context (i.e., <code class="language-plaintext highlighter-rouge">Just 3</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">liftA2 (\f a -&gt; f a)</code> says, apply the function <code class="language-plaintext highlighter-rouge">f</code> to the value (i.e., <code class="language-plaintext highlighter-rouge">(+1) 3</code> which will equate to 4)</li>
</ul>

<p>One thing we can observe is that <code class="language-plaintext highlighter-rouge">(\f a -&gt; f a)</code> is the same thing as <code class="language-plaintext highlighter-rouge">($)</code>. So, we can simplify this to</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Default implementation of &lt;*&gt;</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="c1">-- (&lt;*&gt;) ff fa = liftA2 ($) ff fa</span>
<span class="c1">-- ETA REDUCTION:</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span>
</code></pre></div></div>

<hr>

<div class="cheatsheet">

  <h3 id="different-ways-to-apply-functions-cheatsheet">Different Ways To Apply Functions Cheatsheet</h3>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">g</span> <span class="n">x</span>         <span class="c1">-- apply function g to argument x</span>
 <span class="n">g</span> <span class="o">$</span> <span class="n">x</span>       <span class="c1">-- apply function g to argument x</span>
 <span class="n">g</span> <span class="o">&lt;$&gt;</span> <span class="n">f</span> <span class="n">x</span>   <span class="c1">-- apply function g to argument x which is inside Functor f</span>
 <span class="n">f</span> <span class="n">g</span> <span class="o">&lt;*&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="c1">-- apply function g in Applicative context f to argument x which is also inside f</span>
</code></pre></div>  </div>

</div>

<p>We saw that functions <code class="language-plaintext highlighter-rouge">(-&gt;)</code> are <span class="glossary-term" data-term="functors">Functors<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span>, such that <code class="language-plaintext highlighter-rouge">(&lt;$&gt;)=(.)</code>.  There is also an instance of <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> for functions of input type <code class="language-plaintext highlighter-rouge">r</code>.  We’ll give the types of the essential functions for the instance:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="o">-&gt;</span><span class="p">)</span><span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">)</span>
  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>This is very convenient for creating point-free implementations of functions that operate on their parameters more than once.  For example, imagine our <code class="language-plaintext highlighter-rouge">Student</code> type from above has additional fields with breakdowns of marks: e.g. <code class="language-plaintext highlighter-rouge">exam</code> and <code class="language-plaintext highlighter-rouge">nonExam</code>, requiring a function to compute the total mark:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">totalMark</span> <span class="o">::</span> <span class="kt">Student</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">totalMark</span> <span class="n">s</span> <span class="o">=</span> <span class="n">exam</span> <span class="n">s</span> <span class="o">+</span> <span class="n">nonExam</span> <span class="n">s</span>
</code></pre></div></div>

<p>Here’s the point-free version, taking advantage of the fact that <code class="language-plaintext highlighter-rouge">exam</code> and <code class="language-plaintext highlighter-rouge">nonExam</code>, both being functions of the same input type <code class="language-plaintext highlighter-rouge">Student</code>, are both in the same <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> context:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">totalMark</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">exam</span> <span class="o">&lt;*&gt;</span> <span class="n">nonExam</span>
</code></pre></div></div>

<p>Or equivalently:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">totalMark</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">.</span> <span class="n">exam</span> <span class="o">&lt;*&gt;</span> <span class="n">nonExam</span>
</code></pre></div></div>

<hr>

<h3 id="applicative-exercises">Applicative Exercises</h3>

<ul>
  <li>Derive the implementations of <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> for <code class="language-plaintext highlighter-rouge">Maybe</code> and for functions <code class="language-plaintext highlighter-rouge">((-&gt;)r)</code>.</li>
</ul>

<div class="solutions">
    
<h4 id="solutions">Solutions</h4>

<!-- markdownlint-disable MD036 -->

<p><strong><span class="glossary-term" data-term="maybes">Maybes<span class="glossary-popup">A built-in type in Haskell used to represent optional values, allowing functions to return either Just a value or Nothing to handle cases where no value is available.
</span></span></strong></p>

<p>First let’s consider <code class="language-plaintext highlighter-rouge">Maybe</code>. The type signature for <code class="language-plaintext highlighter-rouge">pure</code> is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</code></pre></div></div>

<p>The idea behind <code class="language-plaintext highlighter-rouge">pure</code> is to take the value of type <code class="language-plaintext highlighter-rouge">a</code> and put it inside the context. So, we take the value <code class="language-plaintext highlighter-rouge">x</code> and put it inside the <code class="language-plaintext highlighter-rouge">Just</code> constructor.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="n">pure</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">x</span>
</code></pre></div></div>

<p>A simple way to define this is to consider all possible options of the two parameters, and define the behaviour
by following the types</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- We can apply the function to the value, we have both!</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="c1">-- Do not have the function, so all we can do is return Nothing</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="c1">-- Do not have the value, so all we can do is return Nothing</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="kt">Nothing</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="c1">-- Do not have value or function, not much we can do here...</span>
</code></pre></div></div>

<p>We observe that only one case returns a value, while all other cases, return <code class="language-plaintext highlighter-rouge">Nothing</code>, so we can simplify our code using the wildcard <code class="language-plaintext highlighter-rouge">_</code> when <span class="glossary-term" data-term="pattern matching">pattern matching<span class="glossary-popup">A mechanism in functional programming languages to check a value against a pattern and to deconstruct data.
</span></span>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- We can apply the function to the value, we have both!</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="kr">_</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span> <span class="c1">-- All other cases, return Nothing</span>
</code></pre></div></div>

<p><strong>Functions</strong></p>

<p>The type definitions for the function type <code class="language-plaintext highlighter-rouge">((-&gt;)r)</code> is a bit more nuanced. When we write <code class="language-plaintext highlighter-rouge">((-&gt;) r)</code>, we are partially applying the <code class="language-plaintext highlighter-rouge">-&gt;</code> type constructor. The <code class="language-plaintext highlighter-rouge">-&gt;</code> type constructor takes two type arguments: an argument type and a return type. By supplying only the first argument <code class="language-plaintext highlighter-rouge">r</code>, we get a type constructor that still needs one more type to become a complete type.</p>

<p>For a bit of intuition around we can make a function in instance of the <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> instance, you can consider the context is an <em>environment r</em>. The <code class="language-plaintext highlighter-rouge">pure</code> function for the reader <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> takes a value and creates a function that ignores the environment and always returns that value. The <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> function for the function instance combines two functions that depend on the <em>same environment</em>.</p>

<p>First, let’s consider <code class="language-plaintext highlighter-rouge">pure</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(((</span><span class="o">-&gt;</span><span class="p">)</span><span class="n">r</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>This may look confusing, but if you replace <code class="language-plaintext highlighter-rouge">((-&gt;)r)</code> with <code class="language-plaintext highlighter-rouge">Maybe</code>, you can see it is essentially the same. Similar to converting prefix functions to infix, we can do the same thing with the type operation here, therefore, this is equivalent to:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>We can follow the types to write a definition for this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="n">pure</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">\</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>This definition takes a single parameter a and returns a function. This function, when given any parameter r, will return the original parameter a. Since all functions are curried in Haskell, this is equivalent to:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="n">pure</span> <span class="n">a</span> <span class="kr">_</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">pure</code> helps you create a function that, no matter what the second input is, will always return this first value, this is exactly the <span class="glossary-term" data-term="k-combinator">K-combinator<span class="glossary-popup">A combinator that takes two arguments and returns the first one.
</span></span>.</p>


</div>

<hr>

<p>As a reminder, the definition for <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>For the function <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>, our <code class="language-plaintext highlighter-rouge">f</code> is <code class="language-plaintext highlighter-rouge">((-&gt;)r)</code></p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(((</span><span class="o">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>Converting the type signature to use <code class="language-plaintext highlighter-rouge">(-&gt;)</code> infix rather than prefix</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
</code></pre></div></div>

<p>For the function body, our function takes two arguments and returns a function of type <code class="language-plaintext highlighter-rouge">r -&gt; b</code>.</p>

<p>We have to do some <a href="https://miro.medium.com/v2/resize:fit:640/format:webp/1*JHP0yCvsO6BD4YxtJs-M1Q.jpeg">Lego</a> to fit the variables together to get out the correct type <code class="language-plaintext highlighter-rouge">b</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="o">=</span> <span class="nf">\</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">r</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">(&lt;*&gt;)</code> takes two functions, one of type <code class="language-plaintext highlighter-rouge">r -&gt; (a -&gt; b)</code> and another of type <code class="language-plaintext highlighter-rouge">r -&gt; a</code>, and combines them to produce a new function of type <code class="language-plaintext highlighter-rouge">r -&gt; b</code>. It does this by applying both functions to the same input <code class="language-plaintext highlighter-rouge">r</code> and then applying the result of the first function to the result of the second.</p>

<p>One neat function we can make out of this, which we will call <code class="language-plaintext highlighter-rouge">apply</code>, passes one argument to a binary function twice, which can be a useful trick.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apply</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">apply</span> <span class="n">f</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">))</span> <span class="n">b</span>
</code></pre></div></div>

<p>or more simply:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apply</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">apply</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">id</span>
</code></pre></div></div>

<p>This will allow us to make more functions point-free</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">square</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span>
<span class="n">square</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">square</span> <span class="n">a</span> <span class="o">=</span> <span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">a</span>
<span class="n">square</span> <span class="o">=</span> <span class="n">apply</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
</code></pre></div></div>
<!-- markdownlint-enable MD036 -->

<h2 id="alternative">Alternative</h2>

<p>The <span class="glossary-term" data-term="alternative">Alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> typeclass is another important typeclass in Haskell, which is closely related to the <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> typeclass. It introduces a set of operators and functions that are particularly useful when dealing with computations that can fail or have multiple possible outcomes. <span class="glossary-term" data-term="alternative">Alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> is also considered a “subclass” of <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>, and it provides additional capabilities beyond what <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> offers. It introduces two main functions, <code class="language-plaintext highlighter-rouge">empty</code> and <code class="language-plaintext highlighter-rouge">&lt;|&gt;</code> (pronounced “alt” or “<span class="glossary-term" data-term="alternative">alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span>”)</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Alternative</span> <span class="p">(</span><span class="n">f</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">empty</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&lt;|&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">empty</code>: This function represents a computation with either <em>no result, or a failure</em>. It serves as the identity element. For different data types that are instances of <span class="glossary-term" data-term="alternative">Alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span>, <code class="language-plaintext highlighter-rouge">empty</code> represents an empty container or a <em>failed computation</em>, depending on the context.</p>

<p><code class="language-plaintext highlighter-rouge">(&lt;|&gt;)</code>: The <code class="language-plaintext highlighter-rouge">&lt;|&gt;</code> operator combines two computations, and it’s used to express <span class="glossary-term" data-term="alternatives">alternatives<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span>. It takes two computations of the same type and returns a computation that will produce a result from the first computation if it succeeds, or if it fails, it will produce a result from the second computation. This operator allows you to handle branching logic and <span class="glossary-term" data-term="alternative">alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> paths in your code.</p>

<p>Like <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> and <span class="glossary-term" data-term="applicative">Applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span>, instances of the <span class="glossary-term" data-term="alternative">Alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> typeclass must also adhere to specific laws, ensuring predictable behaviour when working with <span class="glossary-term" data-term="alternatives">alternatives<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span>. Common instances of the <span class="glossary-term" data-term="alternative">Alternative<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> typeclass include <span class="glossary-term" data-term="maybe">Maybe<span class="glossary-popup">A built-in type in Haskell used to represent optional values, allowing functions to return either Just a value or Nothing to handle cases where no value is available.
</span></span> and lists (<code class="language-plaintext highlighter-rouge">[]</code>). <span class="glossary-term" data-term="alternatives">Alternatives<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> are also very useful for <em><span class="glossary-term" data-term="parsers">Parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span></em>, where we try to run first <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>, if it fails, we run the second <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">2</span> <span class="o">&lt;|&gt;</span> <span class="kt">Just</span> <span class="mi">5</span>
<span class="kt">Just</span> <span class="mi">2</span>

<span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;|&gt;</span> <span class="kt">Just</span> <span class="mi">5</span>
<span class="kt">Just</span> <span class="mi">5</span>
</code></pre></div></div>

<hr>

<h3 id="exercise-1">Exercise</h3>

<ul>
  <li>One useful function, which will be coming up throughout the semester is <code class="language-plaintext highlighter-rouge">asum</code> with the type definition <code class="language-plaintext highlighter-rouge">asum :: Alternative f =&gt; [f a] -&gt; f a</code>. Write this function using <code class="language-plaintext highlighter-rouge">foldr</code>.</li>
</ul>

<div class="solutions">
    
<h4 id="solutions">Solutions</h4>

<p>A naive approach will be to use recursion (recursion is hard).</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asum</span> <span class="o">::</span> <span class="kt">Alternative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">f</span> <span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">asum</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">empty</span> <span class="c1">-- When we reach empty list, return the empty alternative</span>
<span class="n">asum</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;|&gt;</span> <span class="n">asum</span> <span class="n">xs</span> <span class="c1">-- Otherwise recursively combine the first value and the rest of the list</span>
</code></pre></div></div>

<p>However, you may recognise this pattern of recursion to a base case, combining current value with an accumulated value.</p>

<p>This is a classic example of a <em>foldr</em></p>

<p>Therefore we can write <code class="language-plaintext highlighter-rouge">asum</code> simply as:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asum</span> <span class="o">::</span> <span class="kt">Alternative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">f</span> <span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">asum</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">&lt;|&gt;</span><span class="p">)</span> <span class="n">empty</span>
</code></pre></div></div>


</div>

<hr>

<h2 id="a-simple-applicative-functor-for-parsing">A simple Applicative Functor for Parsing</h2>

<p>As we will <a href="/parsercombinators">discuss in more detail later</a>, a <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> is a program that takes some structured input and does something with it.  When we say “structured input” we typically mean something like a string that follows strict rules about its <span class="glossary-term" data-term="syntax">syntax<span class="glossary-popup">The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.
</span></span>, like source code in a particular programming language, or a file format like JSON.  A <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> for a given <span class="glossary-term" data-term="syntax">syntax<span class="glossary-popup">The set of rules that defines the combinations of symbols that are considered to be correctly structured statements or expressions in a computer language.
</span></span> is a program that you run over some input and if the input is valid, it will do something sensible with it (like give us back some data), or fail: preferably in a way that we can handle gracefully.</p>

<p>In Haskell, sophisticated <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> are often constructed from simple functions that try to read a certain element of the expected input and either succeed in consuming that input, returning a tuple containing the rest of the input string and the resultant data, or they fail, producing nothing.  We’ve already seen one type which can be used to encode success or failure, namely <code class="language-plaintext highlighter-rouge">Maybe</code>.  Here’s the most trivial <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> function I can think of. It tries to take a character from the input stream and either succeeds, consuming it, or fails if it’s given an empty string:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parseChar "abc"</span>
<span class="c1">-- Just ("bc",'a')</span>
<span class="c1">-- &gt;&gt;&gt; parseChar ""</span>
<span class="c1">-- Nothing</span>
<span class="n">parseChar</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="n">parseChar</span> <span class="s">""</span> <span class="o">=</span> <span class="kt">Nothing</span>
<span class="n">parseChar</span> <span class="p">(</span><span class="n">c</span><span class="o">:</span><span class="n">rest</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</code></pre></div></div>

<p>And here’s one to parse <code class="language-plaintext highlighter-rouge">Int</code>s off the input stream.  It uses the <code class="language-plaintext highlighter-rouge">reads</code> function from the <span class="glossary-term" data-term="prelude">Prelude<span class="glossary-popup">The default library loaded in Haskell that includes basic functions and operators.
</span></span>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parseInt "123+456"</span>
<span class="c1">-- Just ("+456",123)</span>
<span class="c1">-- &gt;&gt;&gt; parseInt "xyz456"</span>
<span class="c1">-- Nothing</span>
<span class="n">parseInt</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="n">parseInt</span> <span class="n">s</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">reads</span> <span class="n">s</span> <span class="kr">of</span>
  <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">rest</span><span class="p">)]</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="kr">_</span>           <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>So now we could combine these to try to build a little calculator language (OK, all it can do is add two integers, but you get the idea):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parsePlus "123+456"</span>
<span class="c1">-- Just ("",579)</span>
<span class="n">parsePlus</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="n">parsePlus</span> <span class="n">s</span> <span class="o">=</span>
    <span class="kr">case</span> <span class="n">parseInt</span> <span class="n">s</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">s'</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">parseChar</span> <span class="n">s'</span> <span class="kr">of</span>
            <span class="kt">Just</span> <span class="p">(</span><span class="n">s''</span><span class="p">,</span> <span class="sc">'+'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">parseInt</span> <span class="n">s''</span> <span class="kr">of</span>
                <span class="kt">Just</span> <span class="p">(</span><span class="n">s'''</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">s'''</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
                <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
            <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
        <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>But that’s not very elegant and Haskell is all about elegant simplicity.  So how can we use Haskell’s typeclass system to make <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> that are more easily combined?  We’ve seen how things that are instances of the <code class="language-plaintext highlighter-rouge">Functor</code> and <code class="language-plaintext highlighter-rouge">Applicative</code> typeclasses can be combined—so let’s make a type definition for <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> and then make it an instance of <code class="language-plaintext highlighter-rouge">Functor</code> and <code class="language-plaintext highlighter-rouge">Applicative</code>.  Here’s a generic type for <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div></div>

<p>We can now make concrete <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> for <code class="language-plaintext highlighter-rouge">Int</code> and <code class="language-plaintext highlighter-rouge">Char</code> using our previous functions, which conveniently already had functions in the form <code class="language-plaintext highlighter-rouge">(String -&gt; Maybe (String, a))</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">char</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Char</span>
<span class="n">char</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="n">parseChar</span>
<span class="n">int</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span>
<span class="n">int</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="n">parseInt</span>
</code></pre></div></div>

<p>And here’s a simple generic function we can use to run these <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>. All this does is extract the inner function <code class="language-plaintext highlighter-rouge">p</code> from the <code class="language-plaintext highlighter-rouge">Parser</code> constructor:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parse int "123+456"</span>
<span class="c1">-- Just ("+456",123)</span>
<span class="n">parse</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">parse</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span>
</code></pre></div></div>

<p>And a <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> which asserts the next character on the stream is the one we are expecting:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">is</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Char</span>
<span class="n">is</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span>
  <span class="nf">\</span><span class="n">inputString</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">parse</span> <span class="n">char</span> <span class="n">inputString</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">|</span> <span class="n">result</span> <span class="o">==</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<div class="alert-box alert-info">
  <p><strong>Aside: How do we get to that <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>?</strong></p>

  <p>The <code class="language-plaintext highlighter-rouge">is</code> function constructs a <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> that succeeds and consumes a character from the input string if it matches the specified character c, otherwise it fails.</p>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parse (is '+') "+456"</span>
<span class="c1">-- Just ("456",'+')</span>
<span class="c1">-- &gt;&gt;&gt; parse (is '-') "+456"</span>
<span class="c1">-- Nothing</span>
<span class="n">is</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Char</span>
<span class="n">is</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span> <span class="nf">\</span><span class="n">inputString</span> <span class="o">-&gt;</span>
  <span class="kr">case</span> <span class="n">inputString</span> <span class="kr">of</span>
    <span class="kt">[]</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
    <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">x</span> <span class="o">==</span> <span class="n">c</span> <span class="kr">of</span>
      <span class="kt">True</span>  <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
      <span class="kt">False</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div>  </div>

  <p>However, this is quickly becoming very deeply nested. Let’s use our previous <code class="language-plaintext highlighter-rouge">char</code> <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> to ensure correct behaviour for the empty string, rather than duplicating that logic.</p>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parse (is '+') "+456"</span>
<span class="c1">-- Just ("456",'+')</span>
<span class="c1">-- &gt;&gt;&gt; parse (is '-') "+456"</span>
<span class="c1">-- Nothing</span>
<span class="n">is</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Char</span>
<span class="n">is</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span>
  <span class="nf">\</span><span class="n">inputString</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">parse</span> <span class="n">char</span> <span class="n">inputString</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">result</span> <span class="o">==</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="kt">Nothing</span>
    <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div>  </div>

  <p>In this example, the <code class="language-plaintext highlighter-rouge">otherwise = Nothing</code> guard is not needed, as our <code class="language-plaintext highlighter-rouge">case</code> statement can handle that in the wildcard statement</p>

  <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">is</span> <span class="o">::</span> <span class="kt">Char</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Char</span>
<span class="n">is</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span>
  <span class="nf">\</span><span class="n">inputString</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">parse</span> <span class="n">char</span> <span class="n">inputString</span> <span class="kr">of</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">|</span> <span class="n">result</span> <span class="o">==</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div>  </div>

</div>

<p>By making <code class="language-plaintext highlighter-rouge">Parser</code> an instance of <code class="language-plaintext highlighter-rouge">Functor</code>, we will be able to map functions over the result of a parse. This is very useful! For example, consider the <code class="language-plaintext highlighter-rouge">int</code> <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>, which parses a string to an <code class="language-plaintext highlighter-rouge">integer</code>, and if we want to apply a function to the result, such as adding 1 <code class="language-plaintext highlighter-rouge">(+1)</code>, we can fmap this over the <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add1</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span>
<span class="n">add1</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">int</span>
</code></pre></div></div>

<p>We can now use this to parse a string “12”, and get the result 13. <code class="language-plaintext highlighter-rouge">parse add1 "12"</code> will result in <code class="language-plaintext highlighter-rouge">13</code></p>

<p>The <code class="language-plaintext highlighter-rouge">fmap</code> function for the <code class="language-plaintext highlighter-rouge">Functor</code> instance of <code class="language-plaintext highlighter-rouge">Parser</code> needs to apply the <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> to an input string and apply the given function to the result of the parse, i.e.:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span>
    <span class="nf">\</span><span class="n">inputString</span> <span class="o">-&gt;</span> 
      <span class="kr">case</span> <span class="n">p</span> <span class="n">inputString</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">f</span> <span class="n">result</span><span class="p">)</span>
        <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>
<p>These definition is a bit tedious.  We have to explicitly run the <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> and unbox the result of the given <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> (but only if it succeeds), in order to apply the function f to the result.</p>

<p>If we take advantage of the fact that everything buried away inside the <code class="language-plaintext highlighter-rouge">Parser</code> is also an instance <code class="language-plaintext highlighter-rouge">Functor</code>, we can have a much simpler definition of <code class="language-plaintext highlighter-rouge">fmap</code> for <code class="language-plaintext highlighter-rouge">Parser</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span> <span class="n">f</span> <span class="p">(</span><span class="n">fmap</span><span class="o">.</span><span class="n">fmap</span><span class="o">.</span><span class="n">fmap</span><span class="p">)</span> <span class="n">p</span>
</code></pre></div></div>

<hr>

<p><strong>Exercise:</strong> derive this short definition of <code class="language-plaintext highlighter-rouge">fmap</code> for <code class="language-plaintext highlighter-rouge">Parser</code>, from the previous longer version by introducing one nested <code class="language-plaintext highlighter-rouge">fmap</code> at a time.</p>

<div class="solutions">
    
<h3 id="solutions">Solutions</h3>

<p><strong><code class="language-plaintext highlighter-rouge">fmap</code> over <code class="language-plaintext highlighter-rouge">Tuple</code>:</strong>
We can take advantage of the fact that the <code class="language-plaintext highlighter-rouge">Tuple</code> returned by the parse function is also an instance of <code class="language-plaintext highlighter-rouge">Functor</code>.  That is, we are applying the function <code class="language-plaintext highlighter-rouge">f</code> to the second item of a tuple—that is exactly what the <code class="language-plaintext highlighter-rouge">fmap</code> for the <code class="language-plaintext highlighter-rouge">Functor</code> instance of a <code class="language-plaintext highlighter-rouge">Tuple</code> does! So we can rewrite to use the <code class="language-plaintext highlighter-rouge">Tuple</code> <code class="language-plaintext highlighter-rouge">fmap</code>, or rather its alias <code class="language-plaintext highlighter-rouge">(&lt;$&gt;)</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span>
    <span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">p</span> <span class="n">i</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
      <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">fmap</code> over <code class="language-plaintext highlighter-rouge">Maybe</code>:</strong>
Carefully examining this, what we are doing is applying <code class="language-plaintext highlighter-rouge">(f &lt;$&gt;)</code> if the result is a <code class="language-plaintext highlighter-rouge">Just</code>, or ignoring if the result is <code class="language-plaintext highlighter-rouge">Nothing</code>. This is exactly what the <code class="language-plaintext highlighter-rouge">Maybe</code> instance of <code class="language-plaintext highlighter-rouge">Functor</code> does, so we can <code class="language-plaintext highlighter-rouge">fmap</code> over the <code class="language-plaintext highlighter-rouge">Maybe</code> also:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">p</span> <span class="n">i</span> <span class="p">)</span>
</code></pre></div></div>

<p><strong>eta reduce:</strong>
Let’s try rearrange to make it point <a href="/haskell3/#point-free-code">point-free</a>, eliminating the lambda.
First, let’s add some brackets, to make the evaluation order more explicit.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="p">((</span><span class="n">f</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span> <span class="n">i</span><span class="p">))</span>
</code></pre></div></div>

<p>This is now in the form  <code class="language-plaintext highlighter-rouge">(f . g) i)</code> where <code class="language-plaintext highlighter-rouge">f</code> is equal to <code class="language-plaintext highlighter-rouge">((f &lt;$&gt;) &lt;$&gt;)</code> and g is equal to <code class="language-plaintext highlighter-rouge">p</code>. Therefore:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="p">(</span><span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="p">(((</span><span class="n">f</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">.</span> <span class="n">p</span><span class="p">)</span> <span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<p>And, if we eta-reduce:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="p">(((</span><span class="n">f</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">.</span> <span class="n">p</span><span class="p">)</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">fmap</code> over <code class="language-plaintext highlighter-rouge">Function</code>:</strong>
The last thing we notice is that the <code class="language-plaintext highlighter-rouge">Functor</code> instance for functions is defined as compose. Therefore, we have finally reached the end of our journey and can rewrite this as follows.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parse ((*2) &lt;$&gt; int) "123+456"</span>
<span class="c1">-- Just ("+456",246)</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="p">(((</span><span class="n">f</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">p</span><span class="p">)</span>
</code></pre></div></div>

<p>The whacky triple-nested application of <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> comes about because the result type <code class="language-plaintext highlighter-rouge">a</code> in our <code class="language-plaintext highlighter-rouge">Parser</code> type is nested inside a Tuple (<code class="language-plaintext highlighter-rouge">(,a)</code>), nested inside a <code class="language-plaintext highlighter-rouge">Maybe</code>, nested inside a function (<code class="language-plaintext highlighter-rouge">-&gt;r</code>).</p>


</div>

<hr>

<p>So now we can map (or <code class="language-plaintext highlighter-rouge">fmap</code>, to be precise) a function over the value produced by a <code class="language-plaintext highlighter-rouge">Parser</code>.  For example:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">parse</span> <span class="p">((</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;$&gt;</span><span class="n">int</span><span class="p">)</span> <span class="s">"1bc"</span>
<span class="kt">Just</span> <span class="p">(</span><span class="s">"bc"</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>So <code class="language-plaintext highlighter-rouge">(+1)&lt;$&gt;int</code> creates a new <code class="language-plaintext highlighter-rouge">Parser</code> which parses an <code class="language-plaintext highlighter-rouge">int</code> from the input stream and adds one to the value parsed (if it succeeds).  Behind the scenes, using the implementation above, the <code class="language-plaintext highlighter-rouge">Parser</code>’s instance of <span class="glossary-term" data-term="functor">Functor<span class="glossary-popup">A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.
</span></span> is effectively <span class="glossary-term" data-term="lifting">lifting<span class="glossary-popup">The process of applying a function to arguments that are within a context, such as a Functor or Applicative.
</span></span> over three additional layers of nested types to reach the <code class="language-plaintext highlighter-rouge">Int</code> value, i.e.:</p>

<p><img src="/assets/images/chapterImages/haskell3/parserfunctor.png" alt="Applicative Visual Summary"></p>

<p>Just as we have seen before, making our <code class="language-plaintext highlighter-rouge">Parser</code> an instance of <code class="language-plaintext highlighter-rouge">Applicative</code> is going to let us do nifty things like <span class="glossary-term" data-term="lifting">lifting<span class="glossary-popup">The process of applying a function to arguments that are within a context, such as a Functor or Applicative.
</span></span> a binary function over the results of two <code class="language-plaintext highlighter-rouge">Parser</code>s.  Thus, instead of implementing all the messy logic of connecting two <span class="glossary-term" data-term="parsers">Parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> to make <code class="language-plaintext highlighter-rouge">plus</code> above, we’ll be able to lift <code class="language-plaintext highlighter-rouge">(+)</code> over two <code class="language-plaintext highlighter-rouge">Parser</code>s.</p>

<p>Now the definition for the <code class="language-plaintext highlighter-rouge">Applicative</code> is going to stitch together all the messy bits of handling both the <code class="language-plaintext highlighter-rouge">Just</code> and <code class="language-plaintext highlighter-rouge">Nothing</code> cases of the <code class="language-plaintext highlighter-rouge">Maybe</code> that we saw above in the definition of <code class="language-plaintext highlighter-rouge">plus</code>, abstracting it out so that people implementing <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> like <code class="language-plaintext highlighter-rouge">plus</code> won’t have to:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

  <span class="p">(</span><span class="kt">Parser</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span>
    <span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">f</span> <span class="n">i</span> <span class="kr">of</span>                                       <span class="c1">-- note that this is just</span>
      <span class="kt">Just</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">g</span> <span class="n">r1</span> <span class="kr">of</span>                         <span class="c1">-- an abstraction of the</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">p1</span> <span class="n">p2</span><span class="p">)</span>                   <span class="c1">-- logic we saw in `plus`</span>
        <span class="kt">Nothing</span>       <span class="o">-&gt;</span> <span class="kt">Nothing</span>
      <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>All that <code class="language-plaintext highlighter-rouge">pure</code> does is put the given value on the right side of the tuple.</p>

<p>The key insight for this <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> instance is that we first use <code class="language-plaintext highlighter-rouge">f</code> (the <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> on the LHS of <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>). This consumes input from <code class="language-plaintext highlighter-rouge">i</code>, giving back the remaining input in <code class="language-plaintext highlighter-rouge">r1</code>. We then run the second <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> <code class="language-plaintext highlighter-rouge">g</code> on the RHS of <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> on <code class="language-plaintext highlighter-rouge">r1</code> (the remaining input).</p>

<p>The main takeaway message is that <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> allows us to combine two <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> in sequence, that is, we can run the first one and then the second one.</p>

<p>Alternatively, we can think about this in terms of <code class="language-plaintext highlighter-rouge">liftA2</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="p">(</span><span class="nf">\</span><span class="n">input</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

  <span class="n">liftA2</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">pa</span><span class="p">)</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">pb</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span> <span class="nf">\</span><span class="n">input</span> <span class="o">-&gt;</span>
    <span class="kr">case</span> <span class="n">pa</span> <span class="n">input</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="p">(</span><span class="n">rest1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">pb</span> <span class="n">rest1</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">rest2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">rest2</span><span class="p">,</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>
        <span class="kt">Nothing</span>         <span class="o">-&gt;</span> <span class="kt">Nothing</span>
      <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>So, <code class="language-plaintext highlighter-rouge">liftA2</code> lets us run two <span class="glossary-term" data-term="parsers">parsers<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> in <em>sequence</em> and then combine their results with a regular two-argument function — all without manually handling the <code class="language-plaintext highlighter-rouge">Maybe</code> logic.</p>

<p>Let’s walk through a concrete example of this.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">charIntPairParser</span> <span class="o">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="n">char</span> <span class="o">&lt;*&gt;</span> <span class="n">int</span>
<span class="o">&gt;</span> <span class="n">parse</span> <span class="n">charIntPairParser</span> <span class="s">"a12345b"</span>
<span class="kt">Just</span> <span class="p">(</span><span class="s">"b"</span><span class="p">,(</span><span class="sc">'a'</span><span class="p">,</span><span class="mi">12345</span><span class="p">))</span>
</code></pre></div></div>

<p>As both <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> have the same precedence, firstly <code class="language-plaintext highlighter-rouge">(,) &lt;$&gt; char</code> will be evaluated, and then the result will be applied to <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>So how does <code class="language-plaintext highlighter-rouge">(,) &lt;$&gt; char</code> work? Well, we parse a character and then make that character the first item of a tuple, therefore:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">charPairParser</span> <span class="o">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="n">char</span>
<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">charPairParser</span>
<span class="n">charPairParser</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Char</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</code></pre></div></div>

<p>So for the <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> instance, the LHS will be the <code class="language-plaintext highlighter-rouge">charPairParser</code> and the RHS will be <code class="language-plaintext highlighter-rouge">int</code>.
That is, the first step in <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> parsing is to parse the input <code class="language-plaintext highlighter-rouge">i</code> using the LHS <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>, which is what we called here <code class="language-plaintext highlighter-rouge">charPairParser</code>.
This will match the <code class="language-plaintext highlighter-rouge">Just (r1, p1)</code> case where it will be equal to <code class="language-plaintext highlighter-rouge">Just ("12345b", ('a',))</code>. Therefore, <code class="language-plaintext highlighter-rouge">r1</code> is equal to the unparsed portion of the input <code class="language-plaintext highlighter-rouge">12345b</code> and the result is a tuple partially applied <code class="language-plaintext highlighter-rouge">('a', )</code>.</p>

<p>We then run the second <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> <code class="language-plaintext highlighter-rouge">int</code> on the remaining input <code class="language-plaintext highlighter-rouge">"12345b"</code>. This will match the <code class="language-plaintext highlighter-rouge">Just (r2, p2)</code> case where it will be equal to <code class="language-plaintext highlighter-rouge">Just ("b", 12345)</code>, where <code class="language-plaintext highlighter-rouge">r2</code> is equal to the remaining input <code class="language-plaintext highlighter-rouge">"b"</code> and <code class="language-plaintext highlighter-rouge">p2</code> is equal to <code class="language-plaintext highlighter-rouge">"12345"</code></p>

<p>We then return <code class="language-plaintext highlighter-rouge">Just (r2, p1 p2)</code>, which will evaluate to <code class="language-plaintext highlighter-rouge">Just ("b", ('a',12345))</code>.</p>

<p>Using the <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> operator we can make our calculator magnificently simple:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parse plus "123+456"</span>
<span class="c1">-- Just ("",579)</span>
<span class="n">plus</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span>
<span class="n">plus</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">int</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">is</span> <span class="sc">'+'</span> <span class="o">*&gt;</span> <span class="n">int</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that we make use of a different version of the <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> operator here: <code class="language-plaintext highlighter-rouge">*&gt;</code>.  Note also that we didn’t have to provide an implementation of <code class="language-plaintext highlighter-rouge">*&gt;</code> - rather, the typeclass system picks up a default implementation of this operator (and a bunch of other functions too) from the base definition of <code class="language-plaintext highlighter-rouge">Applicative</code>.  These default implementations are able to make use of the <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> that we provided for our instance of <code class="language-plaintext highlighter-rouge">Applicative</code> for <code class="language-plaintext highlighter-rouge">Parser</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>So, compared to <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> which took a function inside the <code class="language-plaintext highlighter-rouge">Applicative</code> as its first parameter which is applied to the value inside the <code class="language-plaintext highlighter-rouge">Applicative</code> of its second parameter,
the <code class="language-plaintext highlighter-rouge">*&gt;</code> carries through the effect of the first <code class="language-plaintext highlighter-rouge">Applicative</code>, but doesn’t do anything else with the value.  You can think of it as a simple chaining of effectful operations: “do the first effectful thing, then do the second effectful thing, but give back the result of the second thing only”.</p>

<p>In the context of the <code class="language-plaintext highlighter-rouge">Parser</code> instance, when we do things like <code class="language-plaintext highlighter-rouge">(is '+' *&gt; int)</code>, we try the <code class="language-plaintext highlighter-rouge">is</code>.  If it succeeds then we carry on and run the <code class="language-plaintext highlighter-rouge">int</code>.  But if the <code class="language-plaintext highlighter-rouge">is</code> fails, execution is short-circuited and we return <code class="language-plaintext highlighter-rouge">Nothing</code>.  There is also a flipped version of the operator which works the other way:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span>
<span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div>

<p>So we could have just as easily implemented the <code class="language-plaintext highlighter-rouge">plus</code> <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- &gt;&gt;&gt; parse plus "123+456"</span>
<span class="c1">-- Just ("",579)</span>
<span class="n">plus</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span>
<span class="n">plus</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">int</span> <span class="o">&lt;*</span> <span class="n">is</span> <span class="sc">'+'</span>  <span class="o">&lt;*&gt;</span> <span class="n">int</span>
</code></pre></div></div>

<p>Obviously, the above is not a fully featured parsing system.  A real <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> would need to give us more information in the case of failure, so a <code class="language-plaintext highlighter-rouge">Maybe</code> is not really a sufficiently rich type to package the result.  Also, a real language would need to be able to handle <span class="glossary-term" data-term="alternatives">alternatives<span class="glossary-popup">A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.
</span></span> - e.g. <code class="language-plaintext highlighter-rouge">minus</code> or <code class="language-plaintext highlighter-rouge">plus</code>, as well as expressions with an arbitrary number of terms.  We will revisit all of these topics with a more feature-rich set of <a href="/parsercombinators"><span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> <span class="glossary-term" data-term="combinators">combinators<span class="glossary-popup">A higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
</span></span> later</a>.</p>

<h3 id="left-and-right-applicatives">Left and Right Applicatives</h3>

<p>We briefly introduced both <code class="language-plaintext highlighter-rouge">(&lt;*)</code> and <code class="language-plaintext highlighter-rouge">(*&gt;)</code> but let’s deep dive in to why these functions are so useful. The full type definitions are:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>

<p>A more intuitive look at these would be:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">(&lt;*)</code>: Executes two actions, but only returns the result of the first action.</li>
  <li><code class="language-plaintext highlighter-rouge">(*&gt;)</code>: Executes two actions, but only returns the result of the second action.</li>
</ul>

<p>The key term here is <em>action</em>. We can consider the <em>action</em> of our <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> as doing the <em>parsing</em>.</p>

<p>A definition of <code class="language-plaintext highlighter-rouge">(&lt;*)</code> is</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*</span><span class="p">)</span> <span class="n">fa</span> <span class="n">fb</span> <span class="o">=</span> <span class="n">liftA2</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="n">fa</span> <span class="n">fb</span>
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">liftA2 = f &lt;$&gt; a &lt;*&gt; b</code>.</p>

<p>Let’s relate this to our parsing and how this <em>executes</em> the two actions. We will consider the example of parsing something in the form of “123+”, wanting to parse the number and ignore the “+”. The execution order will be changed around a little bit, hoping to provide some intuition into these functions.</p>

<p>So, we can use our <code class="language-plaintext highlighter-rouge">&lt;*</code> to ignore the second action, i.e., <code class="language-plaintext highlighter-rouge">int &lt;* (is '+')</code>.</p>

<p>Plugging this into the <code class="language-plaintext highlighter-rouge">liftA2</code> definition:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">liftA2</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="n">int</span> <span class="p">(</span><span class="n">is</span> <span class="sc">'+'</span><span class="p">)</span>
<span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">int</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">is</span> <span class="sc">'+'</span><span class="p">)</span> <span class="c1">-- from the liftA2 definition</span>
<span class="p">((</span><span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">int</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">is</span> <span class="sc">'+'</span><span class="p">)</span> <span class="c1">-- we will complete the functor operator first</span>
</code></pre></div></div>

<p>Recall the definition of <code class="language-plaintext highlighter-rouge">Functor</code> for parsing:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parser</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Parser</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Parser</span> <span class="o">$</span>
    <span class="nf">\</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="kr">case</span> <span class="n">p</span> <span class="n">i</span> <span class="kr">of</span>
      <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="n">f</span> <span class="n">result</span><span class="p">)</span>
      <span class="kr">_</span> <span class="o">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></div></div>

<p>So in this scenario, our function <code class="language-plaintext highlighter-rouge">f</code> is <code class="language-plaintext highlighter-rouge">(\a b -&gt; a)</code> and our <code class="language-plaintext highlighter-rouge">(Parser p)</code> is the <code class="language-plaintext highlighter-rouge">int</code> <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>. <code class="language-plaintext highlighter-rouge">i</code> is the input string “123+”.</p>

<p>Therefore, <code class="language-plaintext highlighter-rouge">(\a b -&gt; a) &lt;$&gt; int</code> will result in <code class="language-plaintext highlighter-rouge">Just ("+", (\a b -&gt; a) 123)</code></p>

<p>Now, we want need to consider the second half, which is</p>

<p><code class="language-plaintext highlighter-rouge">Just ("+", (\a b -&gt; a) 123)</code> being applied to <code class="language-plaintext highlighter-rouge">(is '+')</code></p>

<p>The <span class="glossary-term" data-term="applicative">applicative<span class="glossary-popup">A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).
</span></span> definition says to apply the second <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span> <code class="language-plaintext highlighter-rouge">is '+'</code> to the remaining input, and apply the result to the function inside the RHS of the tuple.</p>

<p>Therefore, after applying this <span class="glossary-term" data-term="parser">parser<span class="glossary-popup">A function or program that interprets structured input, often used to convert strings into data structures.
</span></span>, it will result in: <code class="language-plaintext highlighter-rouge">Just ("", (\a b -&gt; a) 123 "+")</code>. Finally, we will apply the function call to ignore the second value, finally resulting in: <code class="language-plaintext highlighter-rouge">Just ("", 123)</code>. But the key point is we still <em>executed</em> the <code class="language-plaintext highlighter-rouge">is '+'</code>, but we ignored the value. That is the beauty of using our <code class="language-plaintext highlighter-rouge">&lt;*</code> and <code class="language-plaintext highlighter-rouge">*&gt;</code> to ignore results while still <em>executing</em> actions.</p>

<div class="glossary">
  <h2 id="glossary">Glossary</h2>

  <p><em>Operator Sectioning</em>: The process of partially applying an infix operator in Haskell by specifying one of its arguments. For example, (+1) is a section of the addition operator with 1 as the second argument.</p>

  <p><em>Compose Operator</em>: Represented as (.) in Haskell, it allows the composition of two functions, where the output of the second function is passed as the input to the first function.</p>

  <p><em>Point-Free Code</em>: A style of defining functions without mentioning their arguments explicitly. This often involves the use of function composition and other combinators.</p>

  <p><em>Functor</em>: A type class in Haskell that represents types that can be mapped over. Instances of Functor must define the fmap function, which applies a function to every element in a structure.</p>

  <p><em>Applicative</em>: A type class in Haskell that extends Functor, allowing functions that are within a context to be applied to values that are also within a context. Applicative defines the functions pure and (&lt;*&gt;).</p>

  <p><em>Lifting</em>: The process of applying a function to arguments that are within a context, such as a Functor or Applicative.</p>

  <p><em>Alternative</em>: A type class in Haskell that extends Applicative, introducing the empty and &lt;|&gt; functions for representing computations that can fail or have multiple outcomes.</p>

  <p><em>Parser</em>: A function or program that interprets structured input, often used to convert strings into data structures.</p>

  <p><em>Parser Combinator</em>: A higher-order function that takes parsers as input and returns a new parser as output. Parser combinators are used to build complex parsers from simpler ones.</p>

</div>

	</div>
	
  

  


<div id="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      
        
        
        <a id="left" href="/haskell2/">&lt; Data Types and <span class="glossary-term" data-term="type classes">Type Classes<span class="glossary-popup">A type system construct in Haskell that defines a set of functions that can be applied to different types, allowing for polymorphic functions.
</span></span></a>
      
      
        
        
        <a id="right" href="/haskell4/">Foldable and Traversable &gt;</a>
      
    
  
    
  
    
  
    
  
    
  
    
  
</div>

</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">
<footer class="site-footer h-card">
    <data class="u-url" href="/"></data>

    <div class="wrapper">

        <div class="footer-col-wrapper">
            <div class="footer-col">
                <!-- <p class="feed-subscribe">
                <a href="/feed.xml">
                    <svg class="svg-icon orange">
                        <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
                    </svg><span>Subscribe</span>
                </a>
                </p> -->
        </div>
        <div class="footer-col">
            <p>Examples and tutorials for various programming paradigms.</p>
        </div>
    </div>

    <!-- <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="" target="_blank" title="">
      <span class="grey fa-brands fa- fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="" target="_blank" title="">
      <span class="grey fa-brands fa- fa-lg"></span>
    </a>
  </li>
  <li>
    <a href="/feed.xml" target="_blank" title="Subscribe to syndication feed">
      <svg class="svg-icon grey" viewbox="0 0 16 16">
        <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
          11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
          13.806c0-1.21.983-2.195 2.194-2.195zM10.606
          16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
        />
      </svg>
    </a>
  </li>
</ul>
</div> -->

    </div>

</footer>



</body></html>